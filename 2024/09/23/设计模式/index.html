<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>设计模式 | FOLLOWHEART'S BLOG</title><meta name="author" content="FOLLOWHEART"><meta name="copyright" content="FOLLOWHEART"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.设计原则 1.开闭原则Open-Closed Principle, OCP 定义对扩展开放，对修改关闭。 使得程序的扩展性好，易于维护和升级 抽象化是开闭原则的关键。  • 开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则(Principle of Encapsulation of Variation, EVP)要求找到系统的可变 因素并将其封装起来。 Softwa">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2024/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="FOLLOWHEART&#39;S BLOG">
<meta property="og:description" content="1.设计原则 1.开闭原则Open-Closed Principle, OCP 定义对扩展开放，对修改关闭。 使得程序的扩展性好，易于维护和升级 抽象化是开闭原则的关键。  • 开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则(Principle of Encapsulation of Variation, EVP)要求找到系统的可变 因素并将其封装起来。 Softwa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/me.jpg">
<meta property="article:published_time" content="2024-09-23T08:03:52.246Z">
<meta property="article:modified_time" content="2023-06-13T11:49:36.132Z">
<meta property="article:author" content="FOLLOWHEART">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/me.jpg"><link rel="shortcut icon" href="/img/me.jpg"><link rel="canonical" href="http://example.com/2024/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-13 19:49:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/topimg.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="FOLLOWHEART'S BLOG"><img class="site-icon" src="/img/me.jpg"/><span class="site-name">FOLLOWHEART'S BLOG</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-23T08:03:52.246Z" title="发表于 2024-09-23 16:03:52">2024-09-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-13T11:49:36.132Z" title="更新于 2023-06-13 19:49:36">2023-06-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1.设计原则"></a>1.设计原则</h1><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613150954992.png" alt="image-20230613150954992"></p>
<h2 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h2><p><em><strong>Open-Closed Principle, OCP</strong></em></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对扩展开放，对修改关闭。</p>
<p>使得程序的扩展性好，易于维护和升级</p>
<p><strong>抽象化是开闭原则的关键。</strong></p>
<p> • 开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则(Principle of Encapsulation of Variation, EVP)要求找到系统的可变 因素并将其封装起来。</p>
<p>Software entities should be open for extension, but closed for modification.</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613151230819.png" alt="image-20230613151230819"></p>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613151244914.png" alt="image-20230613151244914"></p>
<h2 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2.单一职责原则"></a>2.单一职责原则</h2><p><em><strong>Single Responsibility Principle, SRP</strong></em></p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一个对象应该只包含单一的职责，并且该职责被完整 地封装在一个类中。</p>
<p>Every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class.</p>
<p>就一个类而言，应该仅有一个引起它变化的原因。</p>
<p>There should never be more than one reason for a class to change.</p>
<p>一个类（或者大到模块，小到方法）承担的职责越多， 它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。</p>
<p>类的职责主要包括两个方面：<strong>数据职责</strong>和<strong>行为职责</strong>，数据职责通过其属性来体现，而行为职责通过其方法来体现。</p>
<p>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，在很 多代码重构手法中都能找到它的存在，它是最简单但又 最难运用的原则，需要设计人员发现类的不同职责并将 其分离，而发现类的多重职责需要设计人员具有较强的 分析设计能力和相关重构经验。</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613151540380.png" alt="image-20230613151540380"></p>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613151559287.png" alt="image-20230613151559287"></p>
<h2 id="3-里氏代换原则"><a href="#3-里氏代换原则" class="headerlink" title="3.里氏代换原则"></a>3.里氏代换原则</h2><p><em><strong>Liskov Substitution Principle, LSP</strong></em></p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象</p>
<p>• Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
<p>里氏代换原则可以通俗表述为：在软件中如果能够使用基 类对象，那么一定能够使用其子类对象。把基类都替换成 它的子类，程序将不会产生任何错误和异常，反过来则不 成立，如果一个软件实体使用的是一个子类的话，那么它 不一定能够使用基类。</p>
<p><strong>里氏代换原则是实现开闭原则的重要方式之一</strong>，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><ol>
<li>某系统需要实现对重要数据（如用户密码）的加密处理，在数据操作类(DataOperator)中需要调用加密类中定义的加密算法，系统提供了两个不同的加密类，CipherA和CipherB，它们实现不同的加密方法，在DataOperator中可以选择其中的一个实现加密操作。如图所示：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613152028981.png" alt="image-20230613152028981"></p>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613152134376.png" alt="image-20230613152134376"></p>
<h2 id="4-依赖倒转原则"><a href="#4-依赖倒转原则" class="headerlink" title="4.依赖倒转原则"></a>4.依赖倒转原则</h2><p><em><strong>Dependence Inversion Principle, DIP</strong></em></p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>• 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p>High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.</p>
<p>要针对接口编程，不要针对实现编程。</p>
<p>Program to an interface, not an implementation</p>
<ol>
<li><p>简单来说，依赖倒转原则就是指：<strong>代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程</strong>。</p>
</li>
<li><p>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说<strong>开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段</strong>。</p>
</li>
<li><p>依赖倒转原则的常用实现方式之一是</p>
<p>在代码中使用抽象类，而将具体类放在配置文件</p>
<ol>
<li><strong>将抽象放进代码，将细节放进元数据</strong></li>
<li><strong>Put Abstractions in Code, Details in Metadata</strong></li>
<li>《程序员修炼之道：从小工到专家》(The Pragmatic programmer: from journeyman to master)</li>
</ol>
</li>
<li><p>类之间的耦合</p>
<ol>
<li><strong>零耦合</strong>关系：最好情况</li>
<li><strong>具体耦合</strong>关系</li>
<li><strong>抽象耦合</strong>关系：依赖倒转要求至少一端是抽象的</li>
</ol>
</li>
<li><p>依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。</p>
</li>
<li><p>依赖注入</p>
<ol>
<li>构造注入(Constructor Injection)：通过<strong>构造函数</strong>注入实例变量。</li>
<li>设值注入(Setter Injection)：通过<strong>Setter方法</strong>注入实例变量</li>
<li>接口注入(Interface Injection)：通过<strong>接口方法</strong>注入实例变量。</li>
</ol>
</li>
</ol>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613153640355.png" alt="image-20230613153640355"></p>
<p>由于需求的变化，该系统可能需要增加新的数据源或者新的文件格式，每增加一个新的类型 的数据源或者新的类型的文件格式，客户类 MainClass都需要修改源代码，以便使用新的类 ，但违背了开闭原则。现使用依赖倒转原则对其进行重构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613153737677.png" alt="image-20230613153737677"></p>
<h2 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5.接口隔离原则"></a>5.接口隔离原则</h2><p><em><strong>Interface Segregation Principle, ISP</strong></em></p>
<h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>客户端不应该依赖那些它不需要的接口</p>
<p>Clients should not be forced to depend upon interfaces that they do not use. </p>
<p>注意，在该定义中的接口指的是所定义的方法。</p>
<p>一旦一个接口太大，则需要将它分割成一些更细小的接口， 使用该接口的客户端仅需知道与之相关的方法即可。</p>
<p>Once an interface has gotten too ‘fat’ it needs to be split into smaller and more specific interfaces so that any clients of the interface will only know about the methods that pertain to them. </p>
<ol>
<li><p>接口隔离原则是指</p>
<p>使用多个专门的接口，而不使用单一的总接口</p>
<p>。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。</p>
<ol>
<li>一个接口就<strong>只代表一个角色</strong>，每个角色都有它特定的一个接口，此时这个原则可以叫做”角色隔离原则”。</li>
<li>接口<strong>仅仅提供客户端需要的行为</strong>，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li>
</ol>
</li>
<li><p>使用接口隔离原则拆分接口时，首先必须满足<strong>单一职责原则</strong>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</p>
</li>
<li><p>可以在进行系统设计时采用<strong>定制服务</strong>的方式，即<strong>为不同的客户端提供宽窄不同的接口</strong>，只提供用户需要的行为，而隐藏用户不需要的行为。</p>
</li>
</ol>
<h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><ol>
<li>下图展示了一个拥有多个客户类的系统，在系统中定义了一个巨大的接口（胖接口）AbstractService来服务所有的客户类。可以使用接口隔离原则对其进行重构。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613154836717.png" alt="image-20230613154836717"></p>
<h2 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h2><p><em><strong>Composite Reuse Principle, CRP</strong></em></p>
<h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>尽量使用对象组合，而不是继承来达到复用的 目的。</p>
<p>• Favor composition of objects over inheritance as a reuse mechanism.</p>
<p>合成复用原则就是指在一个新的对象里通过关联 关系（包括组合关系和聚合关系）来使用一些已 有的对象，使之成为新对象的一部分；新对象通 过委派调用已有对象的方法达到复用其已有功能 的目的。简言之：要尽量使用组合&#x2F;聚合关系，少 用继承。</p>
<p>在面向对象设计中，可以通过两种基本方法在不 同的环境中复用已有的设计和实现，即通过组合&#x2F; 聚合关系或通过继承。</p>
<p><strong>继承复用</strong>：实现简单，易于扩展。破坏系统的 封装性；从基类继承而来的实现是静态的，不 可能在运行时发生改变，没有足够的灵活性； 只能在有限的环境中使用。（“白箱”复用 ）</p>
<p><strong>组合&#x2F;聚合复用</strong>：耦合度相对较低，选择性地调 用成员对象的操作；可以在运行时动态进行。 （“黑箱”复用 ）</p>
<p>组合&#x2F;聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合&#x2F;聚合来实现复用 ；其次才考虑继承，在使用继承时，需要严格遵循<strong>里氏代换原则</strong>，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系 统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p>
<h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613155159209.png" alt="image-20230613155159209"></p>
<p>如果需要更换数据库连接方式，如原来采用JDBC连接数据库，现在采用数据库连接池连接，则需要修改DBUtil类源代码。如果StudentDAO采用JDBC连接，但是TeacherDAO采用连接池连接，则需要增加一个新的DBUtil类，并修改StudentDAO或TeacherDAO的源代码，使之继承新的数据库连接类，这将违背开闭原则，系统扩展性较差。</p>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613155242326.png" alt="image-20230613155242326"></p>
<h2 id="7-迪米特法则"><a href="#7-迪米特法则" class="headerlink" title="7.迪米特法则"></a>7.迪米特法则</h2><p><em><strong>Law of Demeter, LoD</strong></em></p>
<p><em><strong>Least Knowledge Principle, LKP</strong></em></p>
<h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>迪米特法则(Law of Demeter, LoD)又称为最少知识原则(Least Knowledge Principle, LKP)，它有多种定义方法，其中几种典型定义如下：</p>
<ol>
<li><strong>不要和”陌生人”说话</strong>。英文定义为：Don’t talk to strangers.</li>
<li><strong>只与你的直接朋友通信</strong>。英文定义为：Talk only to your immediate friends.</li>
<li><strong>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。英文定义为：Each unit should have only limited knowledge about other units: only units “closely” related to the current unit</li>
</ol>
<p>简单地说，迪米特法则就是指<strong>一个软件实体应当尽可能少的与其他实体发生相互作用</strong>。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。</p>
<p>在迪米特法则中，对于一个对象，其朋友包括以下几类：</p>
<ol>
<li>当前对象本身(this)</li>
<li>以参数形式传入到当前对象方法中的对象</li>
<li>当前对象的成员对象</li>
<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li>
<li>当前对象所创建的对象。</li>
</ol>
<p><strong>狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用</strong></p>
<p>如果其中的一个类需要调用另一个类的某一个方法的话，可以通过<strong>第三者转发这个调用</strong>。下图中，只允许A调用B对象的方法，但是不能调用C对象的方法(但是我们可以通过在B中添加一个Wrapper方法来间接调用C)</p>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613155506427.png" alt="image-20230613155506427"></p>
<ol>
<li>狭义的迪米特法则：可以<strong>降低类之间的耦合</strong>，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会<strong>造成系统的不同模块之间的通信效率降低</strong>，使得系统的不同模块之间不容易协调。</li>
<li>广义的迪米特法则：指<strong>对对象之间的信息流量、流向以及信息的影响的控制</strong>，主要是<strong>对信息隐藏的控制</strong>。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。</li>
<li>迪米特法则的主要用途在于控制信息的过载：<ol>
<li>在类的划分上，应当尽量<strong>创建松耦合的类</strong>，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及</li>
<li>在类的结构设计上，每一个类都应当<strong>尽量降低其成员变量和成员函数的访问权限</strong></li>
<li>在类的设计上，只要有可能，<strong>一个类型应当设计成不变类</strong></li>
<li>在对其他类的引用上，<strong>一个对象对其他对象的引用应当降到最低</strong></li>
</ol>
</li>
</ol>
<h3 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h3><ol>
<li><p>某系统界面类(如Form1、Form2等类)与数据访问类(如DAO1、DAO2等类)之间的调用关系较为复杂，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613161130463.png" alt="image-20230613161130463"></p>
</li>
</ol>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613155650423.png" alt="image-20230613155650423"></p>
<h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2.设计模式"></a>2.设计模式</h1><p>设计模式分类</p>
<ol>
<li>模式本身<ol>
<li>创建型</li>
<li>结构型</li>
<li>行为型</li>
</ol>
</li>
<li>模式实现<ol>
<li>类模式：以集成为主要方式实现</li>
<li>对象模式：以合成为主要方式实现</li>
</ol>
</li>
</ol>
<h2 id="1-策略模式"><a href="#1-策略模式" class="headerlink" title="1.策略模式"></a>1.策略模式</h2><p>strategy pattern</p>
<h3 id="模式动机-将文本流分成几行"><a href="#模式动机-将文本流分成几行" class="headerlink" title="模式动机-将文本流分成几行"></a>模式动机-将文本流分成几行</h3><ol>
<li>存在许多用于将文本流分成行的算法。将所有这样的算法硬连接到类中是不可取的。</li>
<li>不满足开闭原则，每次修改都要反复检查每一个条件语句</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String type)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(type.equals(<span class="string">&quot;strategyA&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;strategyB&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;strategyC&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyC</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>在以下情况下使用策略模式<ol>
<li>许多相关的类仅在<strong>行为</strong>上有所不同，策略提供了一种使用多种行为之一配置类的方法</li>
<li>您需要<strong>算法的不同变体</strong>。例如，您可能定义了反映不同空间&#x2F;时间权衡的算法。将这些变体实现为算法的类层次结构时，可以使用策略。</li>
<li>一种算法使用客户端不应该知道的数据。使用策略模式<strong>可避免暴露复杂的、特定于算法的数据结构</strong></li>
<li>一个类定义了许多行为，这些行为在其操作中显示为多个条件语句。代替许多条件，将相关的条件分支移到他们自己的<strong>策略类</strong>中。</li>
</ol>
</li>
<li>很多问题都出现于数据结构被暴露：比如<strong>迭代器模式</strong>。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613193120135.png" alt="image-20230613193120135"></p>
<h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h2><p>factory pattern</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式(Simple Factory Pattern)：又称 为静态工厂方法(Static Factory Method)模式， 它属于类创建型模式。在简单工厂模式中，可以 根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被 创建的实例通常都具有共同的父类。</p>
<p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613193327320.png" alt="image-20230613193327320"></p>
<p>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。 </p>
<p>• 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何 Java源代码。</p>
<p> • 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新 的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</p>
<p> • 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细 节。</p>
<h4 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h4><h5 id="简单工厂模式的优点"><a href="#简单工厂模式的优点" class="headerlink" title="简单工厂模式的优点"></a>简单工厂模式的优点</h5><ol>
<li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅”消费”产品；简单工厂模式通过这种做法<strong>实现了对责任的分割，它提供了专门的工厂类用于创建对象</strong>。</li>
<li><strong>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可</strong>，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li><strong>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</strong>，在一定程度上提高了系统的灵活性。</li>
</ol>
<h5 id="简单工厂模式的缺点"><a href="#简单工厂模式的缺点" class="headerlink" title="简单工厂模式的缺点"></a>简单工厂模式的缺点</h5><ol>
<li>由于<strong>工厂类集中了所有产品创建逻辑</strong>，一旦不能正常工作，整个系统都要受到影响。</li>
<li>使用简单工厂模式将会<strong>增加系统中类的个数</strong>，在一定程序上增加了系统的复杂度和理解难度。</li>
<li><strong>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时</strong>，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。只是把分散在系统各个地方的变化汇总到了一起。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成<strong>工厂角色无法形成基于继承的等级结构</strong>。</li>
</ol>
<h4 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h4><ol>
<li><strong>工厂类负责创建的对象比较少</strong>：由于创建的对象较少，不会造成工厂方法中的业务逻辑<strong>太过复杂</strong>(如果扩展使比较少的)</li>
<li><strong>客户端只知道传入工厂类的参数，对于如何创建对象不关心</strong>：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数(比如只知道名称参数)</li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模 式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对 象，这样做的目的是将产品类的实例化操作延迟到工厂 子类中完成，即通过工厂子类来确定究竟应该实例化哪 一个具体产品类。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="followheart">FOLLOWHEART</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">http://example.com/2024/09/23/设计模式/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">FOLLOWHEART'S BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post_share"><div class="social-share" data-image="/img/me.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/23/%E5%9B%BE%E8%AE%BA/" title="图论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图论</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/23/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/" title="如何写一篇博文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何写一篇博文</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">FOLLOWHEART</div><div class="author-info__description">Laziest coder world champion</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/followheart26"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://githubfast.com/followheart26" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2291886700&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2291886700@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">1.设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.</span> <span class="toc-text">1.开闭原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">2.单一职责原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">3.里氏代换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.</span> <span class="toc-text">4.依赖倒转原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">1.4.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.</span> <span class="toc-text">5.接口隔离原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-number">1.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-4"><span class="toc-number">1.5.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">1.6.</span> <span class="toc-text">6.合成复用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="toc-number">1.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-5"><span class="toc-number">1.6.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-number">1.7.</span> <span class="toc-text">7.迪米特法则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-6"><span class="toc-number">1.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-6"><span class="toc-number">1.7.2.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">8.总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">2.设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">1.策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-%E5%B0%86%E6%96%87%E6%9C%AC%E6%B5%81%E5%88%86%E6%88%90%E5%87%A0%E8%A1%8C"><span class="toc-number">2.1.1.</span> <span class="toc-text">模式动机-将文本流分成几行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">模式优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.2.1.1.1.</span> <span class="toc-text">简单工厂模式的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.1.1.2.</span> <span class="toc-text">简单工厂模式的缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">适用情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">工厂方法模式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="linux程序设计">linux程序设计</a><time datetime="2024-09-23T08:03:52.422Z" title="发表于 2024-09-23 16:03:52">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/jvm/" title="jvm">jvm</a><time datetime="2024-09-23T08:03:52.408Z" title="发表于 2024-09-23 16:03:52">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/java%E5%9F%BA%E7%A1%80/" title="java基础">java基础</a><time datetime="2024-09-23T08:03:52.392Z" title="发表于 2024-09-23 16:03:52">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/javaweb/" title="无题">无题</a><time datetime="2024-09-23T08:03:52.377Z" title="发表于 2024-09-23 16:03:52">2024-09-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/23/git%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/" title="git学习和使用">git学习和使用</a><time datetime="2024-09-23T08:03:52.362Z" title="发表于 2024-09-23 16:03:52">2024-09-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By FOLLOWHEART</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>