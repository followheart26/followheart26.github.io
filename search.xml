<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux程序设计</title>
      <link href="/2024/09/23/linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/09/23/linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、linux基础"><a href="#一、linux基础" class="headerlink" title="一、linux基础"></a>一、linux基础</h1><h2 id="1-许可证"><a href="#1-许可证" class="headerlink" title="1.许可证"></a>1.许可证</h2><p><strong>GPL和BSG</strong></p><p>GPL和BSD是两个比较常见的开源许可，研究一些开源库，比如ffmpeg、vlc、webrtc、ijkplayer等，总能碰到上述字眼儿。今天就想搞明白二者的不同。</p><pre><code>    我们很熟悉的Linux采用的就是GPL许可。GPL许可和BSD、Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux。BSD许可是一个给于使用者很大自由的协议。基本上使用者可以随心所欲的进行二次开发，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。     所以说相对于BSD许可，GPL许可就显得非常严格了。但这种严格需要看对于谁来说。个人而言，肯定更喜欢GPL，公司则更喜欢BSD。前者可以共享大家的劳动成果，后者可以比较方便的获取更大利益。</code></pre><h2 id="2-分区原理"><a href="#2-分区原理" class="headerlink" title="2.分区原理"></a>2.分区原理</h2><h3 id="（1）基础"><a href="#（1）基础" class="headerlink" title="（1）基础"></a>（1）基础</h3><p>基于intel的计算机必须进行分区</p><ol><li>最多四个主分区</li><li>一个主分区可以是扩展分区</li><li>扩展分区可以容纳无限数量的逻辑分区。</li><li>扩展分区无法直接存储数据，要在扩展分区中划分逻辑分区</li></ol><h3 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143519183.png" alt="image-20230525143519183"></p><ol><li>hda：磁盘的第一个扇区包含MBR和分区表(早期的都是MBR组织的，后面使用了GPT(使用GUID分区表))</li><li>hda1：第一个主分区包含Windows 95文件系统</li><li>hda2：第二主分区是扩展分区，拥有三个逻辑分区</li><li>hda5：第一个逻辑分区包含一个Linux文件系统，该文件系统将被安装为&#x2F;</li><li>hda6：第二个逻辑分区包含一个Linux文件系统，该文件系统将挂载为&#x2F;home</li><li>hda7：第三个逻辑分区拥有一个Linux交换空间</li><li>上图中表示是一个双系统，所以同时有windows和linux</li></ol><p>ps.3个逻辑分区属于同一个扩展分区</p><h3 id="（3）MBR"><a href="#（3）MBR" class="headerlink" title="（3）MBR"></a>（3）MBR</h3><p>Main Boot Record 主引导记录区</p><p>位于整个硬盘的0磁道0柱面1扇区。在512字节的主引导扇区中，MBR只占用了其中的446个字节，另外的64个字节交给了 DPT（Disk Partition Table硬盘），最后两个字节“55，AA”是分区的结束标志。</p><h3 id="（4）MBR、扩展分区、逻辑分区"><a href="#（4）MBR、扩展分区、逻辑分区" class="headerlink" title="（4）MBR、扩展分区、逻辑分区"></a>（4）MBR、扩展分区、逻辑分区</h3><ol><li>MBR是整个硬盘最重要的区域，一旦MBR物理实体损坏时，则该硬盘就差不多报废了，一般来说，MBR有512个字节，且可以分为两个部分：<ol><li>第一部分有446个字节，用于存放<strong>引导代码</strong>，即是bootloader。</li><li>第二部分有64个字节，用于存放<strong>磁盘分区表</strong>.其中，每个分区的信息需要用<strong>16个字节</strong>来记录。因此，<strong>一个硬盘最多可以有4个分区</strong>，这4个分区称之为<strong>主分区和扩展分区</strong>(extended)。</li></ol></li><li>重点说明的是，<strong>扩展分区不能直接使用，还需要将其划分为逻辑分区才行</strong>，这样就产生了一个问题，既然扩展分区不能直接使用，但为什么还要划分出一定的空间来给扩展分区呢？这是因为，如果用户想要将硬盘划分为5个分区的话，那该如何？此时，就需要扩展分区来帮忙了。</li><li>由于MBR仅能保存4个分区的数据信息，如果超过4个，系统允许在额外的硬盘空间<strong>存放另一份磁盘分区信息</strong>，这就是扩展分区.若将硬盘分成3P+E，则E实际上是告诉系统，磁盘分区表在另外的那份分区表，即<strong>扩展分区其实是指向正确的额外分区表</strong>.本身扩展分区不能直接使用，还需要额外将扩展分区分成逻辑分区才能使用，因此，用户通过扩展分区就可以使用5个以上的分区了。</li><li>注意：所谓扩展分区，严格地讲<strong>它不是一个实际意义的分区</strong>，它仅仅是一个<strong>指向下一个分区的指针</strong>，这种指针结构将形成一个单向链表。</li></ol><h3 id="（5）GPT"><a href="#（5）GPT" class="headerlink" title="（5）GPT"></a>（5）GPT</h3><p>LBA:逻辑区块地址。是描述电脑存储设备上数据所在区块的通用机制，一般用在像硬盘这样的辅助记忆设备。我们俗称扇区。</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143532496.png" alt="image-20230525143532496"></p><h4 id="LBA0："><a href="#LBA0：" class="headerlink" title="LBA0："></a>LBA0：</h4><p>在GPT分区表的最开头，处于兼容性考虑仍然存储了一份传统的MBR（LBA 0），这个MBR叫做保护性MBR（Protective MBR）。</p><p>保护性MBR保护GPT磁盘不受以前发布的MBR磁盘工具的危害。这些工具不能感知GPT，也无法正确地访问GPT磁盘。这些工具通过解释保护性MBR，将GPT磁盘看成一个封装的（可能无法识别）分区，而不是错误地当成一个未分区的磁盘，并且拒绝对硬盘进行操作。这就避免了意外删除分区的危险。</p><p>在支持从GPT启动的操作系统中，这里也用于存储第一阶段的启动代码。在这个MBR中，只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表。</p><p>在使用MBR&#x2F;GPT混合分区表的硬盘中，这部分存储了GPT分区表的一部分分区（通常是前四个分区），可以使不支持从GPT启动的操作系统从这个MBR启动，启动后只能操作MBR分区表中的分区。</p><h4 id="LBA1："><a href="#LBA1：" class="headerlink" title="LBA1："></a>LBA1：</h4><p>分区表头（LBA 1）定义了硬盘的可用空间以及组成分区表的项的大小和数量。在使用64位Windows Server 2003的机器上，最多可以创建128个分区，即分区表中保留了128个项，其中每个都是128字节。（EFI标准要求分区表最小要有16,384字节，即128个分区项的大小）</p><p>分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还储存着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错，如果出错了，可以使用软件从硬盘最后的备份GPT中恢复整个分区表，如果备份GPT也校验错误，硬盘将不可使用。</p><p>LBA 2–33的位置存放的是分区表项。GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。接下来的16字节是该分区唯一的GUID（这个GUID指的是该分区本身，而之前的GUID指的是该分区的类型）。再接下来是分区起始和末尾的64位LBA编号，以及分区的名字和属性。</p><h4 id="LBA-2–33"><a href="#LBA-2–33" class="headerlink" title="LBA 2–33:"></a>LBA 2–33:</h4><p>LBA 2–33的位置存放的是分区表项。GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。接下来的16字节是该分区唯一的GUID（这个GUID指的是该分区本身，而之前的GUID指的是该分区的类型）。再接下来是分区起始和末尾的64位LBA编号，以及分区的名字和属性。<br><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143548005.png" alt="image-20230525143548005"></p><h2 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3.文件系统"></a>3.文件系统</h2><ol><li>什么是文件系统<ol><li>操作系统中负责访问和管理文件的部分</li><li>文件及其某些属性的集合。它为引用这些文件的文件序列号提供了名称空间。(susv3)</li></ol></li><li>Linux中的文件系统：<ol><li>VFS</li><li>EXT2，EXT3，FAT32等</li></ol></li></ol><h2 id="4-磁盘分区"><a href="#4-磁盘分区" class="headerlink" title="4.磁盘分区"></a>4.磁盘分区</h2><ol><li>至少要创建<ol><li>&#x2F;，750MB(建议1.5G或更高)</li><li>交换，大小等于内存量</li></ol></li><li>推荐：&#x2F;boot(16MB)</li><li>可能需要&#x2F;想要创建其他分区：&#x2F;usr，&#x2F;usr&#x2F;local，&#x2F;var，&#x2F;tmp，&#x2F;opt，&#x2F;home</li><li>Linux下的默认分区程序是fdisk，发行版可以添加自己的分区程序</li></ol><h2 id="5-linux系统启动过程"><a href="#5-linux系统启动过程" class="headerlink" title="5.linux系统启动过程"></a>5.linux系统启动过程</h2><ol><li>BIOS：检查内存，从非易失性内存中加载选项，检查启动设备，加载启动设备的MBR并执行它</li><li>MBR<ol><li>包含一个”boot loader”和分区表</li><li>由LILO&#x2F;GRUB进行传统设置</li></ol></li><li>引导加载程序<ol><li>将压缩的内核映像加载到内存中</li><li>内核解压缩并启动…</li></ol></li><li>初始化过程<ol><li>配置文件&#x2F;etc&#x2F;inittab</li><li>运行水平</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143557173.png" alt="image-20230525143557173"></p><h2 id="6-BIOS基本输入输出系统"><a href="#6-BIOS基本输入输出系统" class="headerlink" title="6.BIOS基本输入输出系统"></a>6.BIOS基本输入输出系统</h2><ol><li>查内存和硬件(POST) Power On Self Test</li><li>从非易失性存储器中加载选项<ol><li>内存时序</li><li>启动设备顺序</li></ol></li><li>检查启动设备：软盘，CD-ROM，硬盘等</li><li>加载启动设备的MBR并执行</li></ol><h2 id="7-引导加载程序-BOOT-LOADER"><a href="#7-引导加载程序-BOOT-LOADER" class="headerlink" title="7.引导加载程序 BOOT LOADER"></a>7.引导加载程序 BOOT LOADER</h2><ol><li>引导加载程序加载并启动Linux内核<ol><li>可以将启动参数传递给Linux内核，例如设备信息</li><li>可以选择加载初始根磁盘</li><li>也可以启动其他操作系统</li></ol></li><li>通用引导加载程序：<ol><li>LILO：Linux加载程序</li><li>GRUB：Grand Unified Boot Loader</li></ol></li><li>除非使用其他引导加载程序，否则通常在&#x2F;dev&#x2F;hda中进行配置。</li></ol><h2 id="8-LILO-Linux加载程序"><a href="#8-LILO-Linux加载程序" class="headerlink" title="8. LILO-Linux加载程序"></a>8. LILO-Linux加载程序</h2><h3 id="1-LILO"><a href="#1-LILO" class="headerlink" title="1.LILO"></a>1.LILO</h3><ol><li>根据配置文件配置MBR的程序。</li><li>必须使用lilo命令以root用户身份运行。</li></ol><h3 id="2-lilo-command语法："><a href="#2-lilo-command语法：" class="headerlink" title="2.lilo command语法："></a>2.lilo command语法：</h3><ol><li>lilo[-v] [-v] [-C配置文件] [-t]</li><li>配置文件：&#x2F;etc&#x2F;lilo.conf</li></ol><h2 id="9-GRUB-GRand统一引导加载程序"><a href="#9-GRUB-GRand统一引导加载程序" class="headerlink" title="9. GRUB-GRand统一引导加载程序"></a>9. GRUB-GRand统一引导加载程序</h2><p>GRUB 比LILO 更好是因为LILO 依赖硬盘的绝对地址来找到引导映像而GRUB 能理解文件系统并寻找包含那个引导映像的文件。</p><ol><li>GRUB</li><li>程序存储在MBR(第一阶段)和&#x2F;boot&#x2F;grub(1.5和第二阶段)中</li><li>了解文件系统结构； 无需像LILO一样激活配置</li><li>配置文件&#x2F;boot&#x2F;grub&#x2F;grub.conf</li><li>通过grub-install安装在MBR中</li></ol><h1 id="二、linux使用"><a href="#二、linux使用" class="headerlink" title="二、linux使用"></a>二、linux使用</h1><h2 id="1-多用户和多任务"><a href="#1-多用户和多任务" class="headerlink" title="1.多用户和多任务"></a>1.多用户和多任务</h2><ol><li>Linux是一个<strong>多用户，多任务</strong>的操作系统：多个用户可以同时运行多个彼此独立的任务。</li><li>在使用系统之前，总是需要”登录”：用<strong>用户名，密码</strong>识别自己</li><li>多种登录系统的方式<ol><li>控制台：直接连接的键盘，鼠标，显示器</li><li>串口</li><li>网络连接</li></ol></li></ol><h2 id="2-虚拟终端"><a href="#2-虚拟终端" class="headerlink" title="2. 虚拟终端"></a>2. 虚拟终端</h2><ol><li>在大多数Linux发行版中，控制台模拟许多虚拟终端</li><li>每个虚拟终端都可以看作是一个单独的直接连接的控制台：不同的用户可以使用不同的虚拟终端</li><li>典型设置：<ol><li>VT 1-6：<strong>文本模式登录</strong></li><li>VT 7：图形模式登录提示(如果启用)</li><li>使用Alt-Fn(如果在X中为Ctrl-Alt-Fn)在VT之间切换</li></ol></li></ol><h2 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令"></a>3.命令</h2><ol><li>passwd：更改密码</li><li>mkpasswd：生成随机密码</li><li>date，cal：找出今天的日期并显示日历</li><li>who，finger：找出谁在系统上处于活动状态</li><li>clear：清除屏幕</li><li>echo：在屏幕上写一条消息</li><li>write、fall、talk、mesg<ol><li>write：给其他用户发信息</li><li>wall：write all给所有登录到系统的用户发信息</li><li>talk：建立聊天session</li><li>mesg：可以屏蔽用户发来的信息</li></ol></li></ol><h2 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h2><ol><li>什么是文件？<ol><li>数据的集合</li><li>可以写入或读取或两者兼有的对象。文件具有某些属性，包括访问权限和类型(susv3)</li></ol></li><li>文件结构<ol><li>通常：字节流，记录序列，记录树</li><li>在Linux中：<strong>字节流</strong></li></ol></li><li>文件在逻辑上是字节，文件必然是整数字节。</li></ol><h2 id="5-文件类型"><a href="#5-文件类型" class="headerlink" title="5.文件类型"></a>5.文件类型</h2><ol><li><strong>普通文件</strong>：文本或代码数据； 没有特别的内部结构</li><li>字符特殊文件</li><li>块特殊文件<ol><li><strong>特殊文件：代表硬件或逻辑设备</strong></li><li>位于名为&#x2F;dev的目录中</li></ol></li><li>socket：<strong>数据接口文件</strong>，最通常工行在<code>/var/run</code>这个目录中看到这种文件类型。</li><li>符号链接<ol><li>软链接：类似windows上的快捷方式</li><li>硬链接：<strong>同一个文件有两个文件名</strong>，创建出来的硬链接不占用磁盘空间和inode号。</li></ol></li><li>**目录(文件夹)**：该目录中的文件列表</li><li>管道文件</li><li>考试要注意是7种</li><li>补充<ol><li>设备文件类型和装载到Linux的<strong>设备驱动</strong>是有关的：指向对应的设备</li><li>在Linux中，以<code>.</code>开头的文件是隐藏文件。</li><li>可以尝试打开<code>/dev/random</code>字符文件(危险，可能字符乱码)</li><li>打开<code>/dev/urandom</code>之后格式恢复</li></ol></li></ol><h2 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6.文件系统"></a>6.文件系统</h2><ol><li><p><code>/boot</code>：内核、bootloader的配置，包括引导加载程序相关的文件。内核的initrd、vmlinux、grub文件位于&#x2F;boot下。</p></li><li><p><code>/etc</code>：系统的配置文件所在地，下载软件的配置文件在也在这里，包含所有程序所需的配置文件</p></li><li><p><code>/bin</code>：程序文件夹，包含二进制可执行文件，例如<code>ls</code>，其实是在执行一个程序；也有一部分程序在<code>/usr/bin</code>(在我的linux上，&#x2F;bin是&#x2F;usr&#x2F;bin的软链接)</p></li><li><p><code>/mnt</code>：<strong>挂载目录</strong>，临时挂载目录，系统管理员可以挂载文件系统。</p></li><li><p><code>/sbin</code>：系统二进制文件，但是这个目录下的Linux命令通常<strong>由系统管理员使用，对系统进行维护</strong>，例如<code>ifconfig/fdisk</code>也有部分程序在<code>/sbin</code>，例如分区命令<code>fdisk</code></p></li><li><pre><code>/usr<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ：资源文件夹(和编程相关的)；编译器、默认的头文件、系统中的库文件，包含二进制文件、库文件、文档和二级程序的源代码</span><br><span class="line"></span><br><span class="line">   1. `/usr/bin`中包含用户程序的二进制文件。`/bin`</span><br><span class="line">   2. `/usr/sbin`中包含系统管理员的二进制文件。`/sbin`</span><br><span class="line">   3. `/usr/lib`中包含了`/usr/bin`和`/usr/sbin`用到的库。</span><br><span class="line">   4. `/usr/local`中包含了从源安装的用户程序。</span><br><span class="line"></span><br><span class="line">7. `/lib`：系统库。包含**支持位于/bin和/sbin下的二进制文件的库文件**；库文件名为 `ld*或lib*.so.*`</span><br><span class="line"></span><br><span class="line">8. `/proc`：包括**系统进行相关信息**。这是一个虚拟的文件系统，包含有关正在运行的进程的信息；系统资源以文本信息形式存在。</span><br><span class="line"></span><br><span class="line">9. ```</span><br><span class="line">   /var：系统里的可变数据，变量文件，并不是存放在磁盘上的数据，一般是存放在内存中的数据。</span><br></pre></td></tr></table></figure>1. 系统日志文件`/var/log`2. 包和数据库文件`/var/lib`3. 电子邮件`/var/mail`4. 打印队列`/var/spool`5. 锁文件`/var/lock`6. 多次重新启动需要的临时文件`/var/tmp`</code></pre></li><li><p><code>/dev</code>：包含<strong>设备文件</strong>，这些包括终端设备、USB或连接到系统的任何设备。例如<code>/dev/tty1</code></p></li><li><p><code>/tmp</code>：包含系统和用户创建的<strong>临时文件</strong>，当系统重新启动时，这个目录下的文件都将被删除。</p></li><li><p><code>/home</code>：用home目录来存储他们的个人档案。</p></li><li><p><code>/opt</code>：可选的附加应用程序</p></li><li><p><code>/media</code>：用于挂载<strong>可移动设备</strong>的临时目录。举例来说，挂载CD-ROM的&#x2F;media&#x2F;cdrom，挂载软盘驱动器的&#x2F;media&#x2F;floppy</p></li><li><p><code>/srv</code>：srv代表服务。包含服务器特定服务相关的数据。</p></li><li><p>修改环境变量PATH，临时修改可以直接<code>PATH=$PATH:/bin</code>，但是要永久生效得修改配置文件<code>/etc/profile</code></p></li></ol><h2 id="7-文件权限"><a href="#7-文件权限" class="headerlink" title="7.文件权限"></a>7.文件权限</h2><ol><li>文件权限可帮助您保护文件免受他人侵害系统上的用户</li><li>三个访问级别：<ol><li>用户：创建文件的用户</li><li>组：拥有文件的组中的所有用户</li><li>其他：其他</li></ol></li><li>三个权限：<ol><li>读取(R)：读取文件内容或列表内容目录</li><li>写(w)：更改文件内容或创建&#x2F;删除文件在目录中</li><li>执行(x)：以程序执行文件或使用目录作为活动目录</li></ol></li></ol><p>文件默认权限：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File: -rw-r--r--644</span><br><span class="line">Directory: drwxr-xr-x 755</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143616446.png" alt="image-20230525143616446"></p><p><strong>修改权限</strong></p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143630583.png" alt="image-20230525143630583"></p><h2 id="8-进程"><a href="#8-进程" class="headerlink" title="8.进程"></a>8.进程</h2><h3 id="1-开始和停止进程"><a href="#1-开始和停止进程" class="headerlink" title="1.开始和停止进程"></a>1.开始和停止进程</h3><ol><li>所有流程均由其他流程启动<ol><li>父母&#x2F;子女关系</li><li>一个例外：init（PID 1）由内核本身启动</li><li>树的层次结构</li></ol></li><li>可以终止进程的原因有两个：<ol><li>该进程完成后会自行终止。</li><li>该进程被另一个进程的信号终止</li></ol></li></ol><h3 id="2-基本命令"><a href="#2-基本命令" class="headerlink" title="2.基本命令"></a>2.基本命令</h3><ol><li>ps：报告进程状态</li><li>pstree：显示进程树</li><li>jobs，fg，bg，：作业控制bg：后台执行fg：前台执行</li><li>kill：</li><li>nohup：运行命令，忽略挂断信号</li><li>nice，kill：</li><li>top：显示最热门的CPU进程</li></ol><h3 id="3-Daemons-守护进程"><a href="#3-Daemons-守护进程" class="headerlink" title="3.Daemons 守护进程"></a>3.Daemons 守护进程</h3><p>“守护进程”一词指的是一个永无止境的进程，通常是控制诸如打印机队列之类的系统资源或执行网络服务的系统进程。</p><h2 id="9-如何寻求帮助？"><a href="#9-如何寻求帮助？" class="headerlink" title="9. 如何寻求帮助？"></a>9. 如何寻求帮助？</h2><ol><li>“man”命令</li><li>info</li><li>command–help</li><li>HOWTO文档</li><li>参考互联网</li></ol><h3 id="1-man-命令"><a href="#1-man-命令" class="headerlink" title="1. man 命令"></a>1. man 命令</h3><ol><li>使用man命令，您可以阅读命令的手册页</li><li>手册页存储在&#x2F;usr&#x2F;man中</li><li>手册页包括：<ol><li>名称：命令名称和在线说明</li><li>简介：命令的语法</li><li>说明：有关命令的工作方式及其作用的说明</li><li>文件：命令使用的文件</li><li>错误：已知的错误和错误</li><li>另请参阅：与此命令相关的其他命令</li></ol></li><li>“-k”选项：man–k打印</li><li>手册分为8个部分：<ol><li>用户命令</li><li>系统调用</li><li>库调用</li><li>设备</li><li>文件格式和协议</li><li>游戏</li><li>公约，宏程序包等</li><li>系统管理</li></ol></li><li>要选择正确的部分，请添加部分编号：man1 passwd，man 5 passwd</li></ol><h3 id="2-info-命令"><a href="#2-info-命令" class="headerlink" title="2. info 命令"></a>2. info 命令</h3><ol><li>用于阅读文档的程序，有时可以代替手册页</li><li>有关信息的信息存储在&#x2F; usr &#x2F; info中</li><li>一些信息命令：<ol><li>space：下一屏文字</li><li>delete：上一屏文字</li><li>n：下一个节点</li><li>p：上一个节点</li><li>u：上节点</li><li>q：退出信息</li><li>&lt; tab &gt;：跳至下一个菜单项</li></ol></li></ol><h1 id="三、shell"><a href="#三、shell" class="headerlink" title="三、shell"></a>三、shell</h1><h2 id="1-Shell-的双重角色"><a href="#1-Shell-的双重角色" class="headerlink" title="1.Shell 的双重角色"></a>1.Shell 的双重角色</h2><ol><li>命令解释程序<ol><li>Linux的开机启动过程；进程树</li><li>Shell的工作步骤<ol><li>打印提示符；得到命令行；解析命令；查找文件；准备参数；执行命令</li></ol></li></ol></li><li>独立的程序设计语言解释器<ol><li>KISS (Keep It Small and Stupid)</li><li>Reusable tools</li><li>Redirection and pipe</li></ol></li></ol><h2 id="2-执行脚本"><a href="#2-执行脚本" class="headerlink" title="2.执行脚本"></a>2.执行脚本</h2><ol><li>method 1: <code>sh script_file</code></li><li>Method 2:<ol><li><code>chmod +x script_file (chown, chgrp optionally)</code></li><li><code>./script_file</code></li></ol></li><li>Method 3:<ol><li><code>source script_file, or</code></li><li><code>. script_file</code></li></ol></li></ol><p>区别在于，source .在本bash进行，前两个运行于子bash</p><h2 id="3-用户环境"><a href="#3-用户环境" class="headerlink" title="3.用户环境"></a>3.用户环境</h2><ol><li><pre><code>.bash_profile<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>.bash_logout<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>.bashrc files<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   1. `.bash_profile`: 用户登录时被读取，其中包含的命令被bash执行</span><br><span class="line">   2. `.bashrc`: 启动一个新的shell时读取并执行</span><br><span class="line">   3. `.bash_logout`: 登录退出时读取执行</span><br><span class="line"></span><br><span class="line">2. Alias</span><br><span class="line"></span><br><span class="line">   1. alias/unaliascommand</span><br><span class="line"></span><br><span class="line">3. 环境变量</span><br><span class="line"></span><br><span class="line">   1. export command</span><br><span class="line">   2. export, env &amp; set command</span><br><span class="line"></span><br><span class="line"># 四、编程前提</span><br><span class="line"></span><br><span class="line">## 1. 编程原则</span><br><span class="line"></span><br><span class="line">1. 抽象和具体</span><br><span class="line">2. 库(API)的调用与选择：从技术角度，一般使用标准库，如果使用商业库，则会给对方平台带来一定的收益，但是对自己而言，平台移植性比较低。</span><br><span class="line"></span><br><span class="line">## 2. 编程工具</span><br><span class="line"></span><br><span class="line">1. 编辑工具：vi, emacs</span><br><span class="line"></span><br><span class="line">2. 编译、链接：gcc</span><br><span class="line"></span><br><span class="line">3. 调试：gdb</span><br><span class="line"></span><br><span class="line">4. make命令</span><br><span class="line"></span><br><span class="line">5. 版本控制工具：CVS等</span><br><span class="line"></span><br><span class="line">6. 永久修改环境变量的方法`profile`，但是当前窗口修改是不影响的。</span><br><span class="line"></span><br><span class="line">   ```shell</span><br><span class="line">   .profile</span><br><span class="line">   .profile 文件在主（$HOME）目录中，并使您能够定制个人工作环境。因为 .profile 文件是隐藏的，所以请使用 ls -a 命令列出它。</span><br><span class="line">   </span><br><span class="line">   在 login 程序将 LOGNAME（登录名）和 HOME（登录目录）变量添加到环境中后，将会执行 $HOME/.profile 文件中的命令（如果此文件存在）。 .profile 文件包含覆盖 /etc/profile 文件中变量集的个人概要文件。 .profile 文件通常用于设置导出的环境变量和终端方式。可通过修改 .profile 文件来定制环境。</span><br><span class="line">   按照生命周期来分，Linux 环境变量可以分为两类：</span><br><span class="line">   1、永久的：需要用户修改相关的配置文件，变量永久生效。</span><br><span class="line">   2、临时的：用户利用 export 命令，在当前终端下声明环境变量，关闭 shell 终端失效。</span><br></pre></td></tr></table></figure></code></pre></li></ol><h2 id="3-编程语言"><a href="#3-编程语言" class="headerlink" title="3. 编程语言"></a>3. 编程语言</h2><ol><li>更高层语言<ol><li>C&#x2F;C++，Java，Fortan</li><li>ELF binary format<ol><li>Excutable and Linkable Format<ol><li>windows下可执行文件的封装格式: MZ</li><li>linux下的可执行文件封装格式: ELF，封装一般发生在链接过程中</li></ol></li><li>工具接口标准委员会(TIS)选择了正在发展中的ELF体系上不同操作系统之间可移植的二进制文件格式</li></ol></li></ol></li></ol><h2 id="4-开发工具"><a href="#4-开发工具" class="headerlink" title="4. 开发工具"></a>4. 开发工具</h2><ol><li>GCC：Linux下的C编译器，微软的C编译器：cl，开源编译器：clang，和gcc差不多。<ol><li>GNU C Compiler -&gt; GNU Compiler Collection</li><li>The gcc command: Front end</li></ol></li><li>GDB<ol><li>GNU Debugger</li><li>The gdb command</li><li>xxdgb, ddd…</li></ol></li><li>Binary utilities 附带元件<ol><li>as, ld, ar, ldd…</li></ol></li><li>Make</li></ol><h2 id="5-最简单的编译连接图-Win"><a href="#5-最简单的编译连接图-Win" class="headerlink" title="5. 最简单的编译连接图(Win)"></a>5. 最简单的编译连接图(Win)</h2><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143643154.png" alt="image-20230525143643154">](<a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Linux-Programming/img/lec3/1.png">https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Linux-Programming/img/lec3/1.png</a>)</p><h2 id="6-编译链接图-展开"><a href="#6-编译链接图-展开" class="headerlink" title="6. 编译链接图(展开)"></a>6. 编译链接图(展开)</h2><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143653241.png" alt="image-20230525143653241"></p><ol><li>每一个源代码和目标文件是一一对应的</li><li>链接器是将所有的目标文件进行链接</li><li>打包后就得到了.a(也就是一个静态库)</li><li>为什么需要静态库：<ol><li>因为随着开发的推进，程序越来越大，则需要通过静态库的方法来降低复杂度。</li><li>升级更新要尽量做到是增量更新的</li><li>但是静态库会导致复用性降低，磁盘过多被占用</li></ol></li><li>动态库的作用<ol><li>不放在可执行文件中，放在外面</li><li>升级的时候会很方便</li><li>动态库会存在冲突(版本问题)</li></ol></li></ol><h2 id="7-预处理阶段"><a href="#7-预处理阶段" class="headerlink" title="7.预处理阶段"></a>7.预处理阶段</h2><p><strong>预处理本质是将我们的代码进行预先处理。主要分为四个步骤：1.去注释； 2.宏替换； 3.条件编译； 4.头文件展开</strong></p><h3 id="1-宏替换"><a href="#1-宏替换" class="headerlink" title="1.宏替换"></a>1.宏替换</h3><p>宏替换就是直接替换，可能会有问题。</p><p><strong>宏从定义处向下都是有效的，与函数调用无关（因为宏替换在函数调用之前），只是简单的文本替换</strong></p><p><strong>#undef就是用来取消宏定义的</strong></p><p><strong>#undef又可以称为限制宏，写在宏定义的下面，#undef的上面才是宏的有效范围（限制了宏的作用范围）</strong></p><h3 id="2-条件编译-可用于分收费版和免费版"><a href="#2-条件编译-可用于分收费版和免费版" class="headerlink" title="2.条件编译(可用于分收费版和免费版)"></a>2.条件编译(可用于分收费版和免费版)</h3><p>1.#ifdef和#ifndef的用法<br>通常用于检测一个宏是否被定义（主要与宏为真为假区分开来）。这两个通常与#else，#endif一起用（看起来跟if，else类似）</p><p>#ifdef是表肯定。如果宏被定义,则该代码保留<br>#ifndef表示否定。如果没有被定义，则该代码保留</p><h2 id="8-编译链接"><a href="#8-编译链接" class="headerlink" title="8.编译链接"></a>8.编译链接</h2><ol><li><p>头文件和#include (预处理 – 编译时处理)</p></li><li><p>为什么要做链接？(link)</p><p>库函数</p></li><li><p>静态库与动态库</p></li></ol><h2 id="9-依赖库和头文件"><a href="#9-依赖库和头文件" class="headerlink" title="9.依赖库和头文件"></a>9.依赖库和头文件</h2><ol><li>静态库(.a 文件)：Lab(gcc + ar)</li><li>动态库&#x2F;共享对象(.so 文件)：Lab(gcc）</li></ol><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>静态库的原理<br>用静态库封装功能函数，在程序编译到 链接库 步骤，将静态库函数 继承 到二进制文件中，最终生成一个可执行二进制程序；</p><p>优点：</p><p>程序运行的时候，与静态库没有任何关系，可以完全脱离静态库</p><p>方便移植；</p><p>缺点：</p><p>存储的时候浪费磁盘空间</p><p>运行的时候浪费内存空间</p><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>动态库，把库函数的链接推迟到程序运行的时候。</p><p>当程序执行到库函数的时候，会去找动态库中的相关函数。如果内存中不存在该动态库，则会将动态库加载到内存中。</p><p>如果内存中已经存在该动态库，则直接调用动态库。</p><p>优点：</p><p>可执行程序运行的时候，节省内存空间。</p><p>程序存储的时候，节省磁盘空间。</p><p>缺点：</p><p>程序运行的时候，如果没有找到动态库，则会导致程序崩溃。</p><h2 id="10-其他语言"><a href="#10-其他语言" class="headerlink" title="10.其他语言"></a>10.其他语言</h2><p>托管代码是直接被编译器编译成机器指令的，那么被编译后的可执行程序只能在特定的CPU架构、OS上运行，更换了运行环境则必须重新进行编译。托管代码类的语言：C、C++等。</p><p>非托管代码：</p><p>托管代码则是将代码编译成中间文件，然后由虚拟机翻译成机器指令（不同平台的虚拟机功能是一样的，但是实现是不同的），这样就可以一次编译处处运行。非托管代码类的语言：C#、Java。对于C#来说，我们的操作系统上必须安装对应的.NET Framework类库和虚拟机。</p><h2 id="11-gcc（要背）"><a href="#11-gcc（要背）" class="headerlink" title="11.gcc（要背）"></a>11.gcc（要背）</h2><ol><li>Usage:<ol><li>gcc [options] [filename]</li></ol></li><li>Basic options:<ol><li>-E: 只对源程序进行预处理(调用cpp预处理器)</li><li>-S: 只对源程序进行预处理、编译</li><li>-c: 执行预处理、编译、汇编而不链接</li><li>-o output_file: 指定输出文件名</li><li>-g: 产生调试工具必需的符号信息</li><li>-O&#x2F;On: 在程序编译、链接过程中进行优化处理</li><li>-Wall: 显示所有的警告信息</li></ol></li><li>Basic options:<ol><li><code>-Idir</code>: 指定额外的<strong>头文件</strong>搜索路径</li><li><code>-Ldir</code>: 指定额外的<strong>库文件</strong>搜索路径</li><li><code>-lname</code>: 链接时搜索指定的库文件</li><li><code>-DMACRO[=DEFN]</code>: 定义MACRO宏(针对#define)</li></ol></li><li>编译后调试一般在一台机器上，而不会在多台机器</li><li>补充：<ol><li>调试的时候仍然使用的是本地编译好的二进制文件</li><li>编译的时候没开优化，源代码的语句编译成的汇编码是多条语句，是一对多的关系</li><li>调试器：在执行编译后的二进制码，二进制码会被打标签，记录哪一个源代码的哪一行编译而来的。</li><li>-g参数：告诉编译器，每一个编译完的二进制码上打上文件名和行号的标签</li><li>编译完之后，用其他的机器调试可能是不行的，因为file的路径一般是不一样的。</li><li>-O优化，二进制码打乱，不优化的话，源代码和汇编代码是对应着的；一些无关的操作会被编译器扔掉；会把源代码和汇编码之间一对多的关系破坏掉</li></ol></li><li>在不改变源代码的基础上，在文件中添加#define预处理指令。</li></ol><h2 id="12-GDB"><a href="#12-GDB" class="headerlink" title="12.GDB"></a>12.GDB</h2><ol><li>GDB: GNU Debug<ol><li>设置断点</li><li>监视变量值</li><li>单步执行</li><li>修改变量值</li></ol></li><li>GDB commands</li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143730129.png" alt="image-20230525143730129"></p><h2 id="13-make-makefile"><a href="#13-make-makefile" class="headerlink" title="13. make &amp; makefile"></a>13. make &amp; makefile</h2><ol><li><p>Multi-file project</p><ol><li>IDE</li><li>make</li></ol></li><li><p>make &amp; makefile</p><ol><li>makefile描述模块间的依赖关系；</li><li>make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系</li></ol></li><li><p>Hello 的 Makefile</p></li></ol><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOPDIR = ../</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(TOPDIR)</span>Rules.mak</span><br><span class="line">EXTRA LIBS += :</span><br><span class="line">EXEC = <span class="variable">$(INSTALL_DIR)</span>/hello</span><br><span class="line">OBJS = hello.o <span class="comment"># make uninstall之后系统中源代码仍然存在</span></span><br><span class="line"><span class="comment"># 变量定义，makefile可以include别的makefile</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(EXEC)</span> # 默认执行make all</span></span><br><span class="line">  <span class="variable">$(EXEC)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -0 <span class="variable">$@</span> <span class="variable">$(OBJS)</span> <span class="variable">$(EXTRA_ LIBS)</span> <span class="comment"># gcc的别名CC，$@明确了目标文件放置位置</span></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">  <span class="variable">$(EXP_ INSTALL)</span> <span class="variable">$(EXEC)</span> <span class="variable">$(INSTALL_ DIR)</span> <span class="comment"># make install执行的指定目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  -rm -f <span class="variable">$(EXEC)</span> *.elf*.gdb *.o</span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><ol><li>定义整个工程的编译规则：<ol><li>一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作 。</li></ol></li><li>自动化编译：<ol><li><strong>只需要一个make命令</strong>，整个工程完全自动编译</li><li>make是一个命令工具，是一个解释makefile中指令的命令工具；</li></ol></li><li>默认情况下，每执行一条 makefile 中的命令之前，<strong>Shell 终端都会显示出这条命令的具体内容</strong>，除非该命令用分号分隔而紧跟在依赖关系后面，我们称之为”回显”。如果不想显示命令的具体内容，我们可以在命令的开头加上”@”符号，这种情况通常用于 echo 命令。</li><li><code>$&#123;MAKE&#125;</code>就是预设的 make 这个命令的名称（或者路径）。</li><li>GNU make是一个命令工具，是一个用来控制软件构建过程的自动化管理工具。Make工具通过称为Makefile的文件来完成并自动维护编译工作,由Richard Stallman与Roland McGrath设计开发。</li><li>Makefile是用于自动编译和链接的，一个工程有很多文件组成，每一个文件的改变都会导致工程的重新链接，但是不是所有的文件都需要重新编译，Makefile中记录有文件的信息，在make时会决定在链接的时候需要重新编译哪些文件。</li><li>make命令格式：<code>make [-f Makefile] [option] [target]</code></li><li><code>#make target #make #make clean</code></li></ol><h3 id="1-make"><a href="#1-make" class="headerlink" title="1. make"></a>1. make</h3><ol><li><code>make [-f filename] [targetname]</code></li><li>Targets<ol><li>A target is usually the name of a file that is generated by a program; examples of targets are executable or object files.</li><li>A target can also be the name of an action to carry out, such as ‘clean’ (phony target).</li></ol></li><li>make install 需要 root 权限</li><li>如果 config 的时候使用 root 权限，则编译后产生的所有文件都需要root权限</li><li>直接make命令，则<strong>执行的就是编译链接的部分</strong>。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># automake方式</span><br><span class="line">./configure #生成新的makefile</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">make uninstall</span><br><span class="line">make clean</span><br><span class="line">make distclean# 退回到configure之前(删除makefile)</span><br><span class="line"></span><br><span class="line">SHELL</span><br></pre></td></tr></table></figure><h3 id="2-Makefile-规则结构"><a href="#2-Makefile-规则结构" class="headerlink" title="2. Makefile 规则结构"></a>2. Makefile 规则结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ... </span><br><span class="line">command</span><br><span class="line"></span><br><span class="line">BASH</span><br></pre></td></tr></table></figure><ol><li>target是一个目标文件，可以是Object File，也可以是执行文件</li><li>prerequisites是要生成target所需要的文件或是目标</li><li>command是make需要执行的命令。(可以是任意的Shell命令)</li><li>举例：依赖关系，如果后面的文件更新，则执行如下代码，若输出文件不存在是执行如下代码则为违反规则。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello : main.o kbd.o</span><br><span class="line">  gcc -o hello main.o kbd.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">  cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">  cc -c kbd.c</span><br><span class="line">clean :</span><br><span class="line">  rm edit main.o kbd.o # 伪目标</span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><ol><li>只是匹配次序，并不是执行次序。</li><li>make的执行：时间戳检查、文件检查。</li></ol><h3 id="3-Hello的makefile"><a href="#3-Hello的makefile" class="headerlink" title="3. Hello的makefile"></a>3. Hello的makefile</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TOPDIR = ../</span><br><span class="line">include $(TOPDIR)Rules.mak</span><br><span class="line">EXTRA_LIBS +=</span><br><span class="line">EXEC = $(INSTALL_DIR)/hello</span><br><span class="line">OBJS = hello.o</span><br><span class="line">all: $(EXEC)</span><br><span class="line">   $(EXEC): $(OBJS)</span><br><span class="line">   $(CC) $(LDFLAGS) -o $@ $(OBJS) $(EXTRA_LIBS)</span><br><span class="line">install:</span><br><span class="line">   $(EXP_INSTALL) $(EXEC) $(INSTALL_DIR)</span><br><span class="line">clean:</span><br><span class="line">   -rm -f $(EXEC) *.elf *.gdb *.o</span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><h3 id="4-Makefile-执行次序"><a href="#4-Makefile-执行次序" class="headerlink" title="4. Makefile 执行次序"></a>4. Makefile 执行次序</h3><ol><li>make会在当前目录下找名字叫”Makefile”或”makefile”的文件。</li><li>查找文件中的第一个目标文件(target)，举例中的hello</li><li>如果hello文件不存在，或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件。</li><li>如果hello所依赖的.o文件不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。(类似一个堆栈的过程)</li><li>make根据.o文件的规则生成 .o 文件，然后再用 .o 文件生成hello文件。</li></ol><h3 id="5-伪目标"><a href="#5-伪目标" class="headerlink" title="5. 伪目标"></a>5. 伪目标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">   rm *.o hello</span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><ol><li>“伪目标”并不是一个文件，只是一个标签，所以make无法生成它的依赖关系和决定它是否要执行，只能通过显示地指明这个”目标”才能让其生效</li><li>“伪目标”的取名不能和文件名重名</li><li>为了避免和文件重名的这种情况，可以使用一个特殊的标记”.PHONY”来显示地指明一个目标是”伪目标”，向make说明，不管是否有这个文件，这个目标就是”伪目标”</li><li>伪目标一般没有依赖的文件，但也可以为伪目标指定所依赖的文件。</li><li>伪目标同样可以作为”默认目标”，只要将其放在第一个。</li></ol><h3 id="6-多目标"><a href="#6-多目标" class="headerlink" title="6. 多目标"></a>6. 多目标</h3><ol><li>用处<ol><li>当多个目标同时依赖于一个文件，并且其生成的命令大体类似，可以使用一个自动化变量”$@”表示着目前规则中所有的目标的集合</li></ol></li><li>举例</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">generate text.g -$(subst output,,$@) &gt; $@ # 将$@中的output替换成空</span><br><span class="line"></span><br><span class="line">#上述规则等价于</span><br><span class="line">bigoutput : text.g</span><br><span class="line">  generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">  generate text.g -little &gt; littleoutput </span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><h3 id="7-预定义变量"><a href="#7-预定义变量" class="headerlink" title="7. 预定义变量"></a>7. 预定义变量</h3><ol><li><code>$&lt;</code> 第一个依赖文件的名称</li><li><code>$?</code> 所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li><li><code>$+</code> 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li><code>$^</code> 所有的依赖文件，以空格分开，不包含重复的依赖文件</li><li><code>$*</code> 不包括扩展名的目标文件名称</li><li><code>$@</code> 目标的完整名称</li><li><code>$%</code> 如果目标是归档成员，则该变量表示目标的归档成员名称</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">  insert.o search.o files.o utils.o</span><br><span class="line">  gcc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">  insert.o search.o files.o utils.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">  gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">  gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">  gcc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">  gcc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">  gcc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">  gcc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">  gcc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">  gcc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">  rm edit main.o kbd.o command.o display.o \</span><br><span class="line">  insert.o search.o files.o utils.o</span><br><span class="line">OBJECTS = main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">edit : $(OBJECTS)</span><br><span class="line">  gcc -o edit $(OBJECTS)</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">  gcc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">  gcc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">  gcc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">  gcc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">  gcc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">  gcc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">  gcc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">  gcc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">  rm edit $(OBJECTS) </span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><h3 id="8-多目标扩展"><a href="#8-多目标扩展" class="headerlink" title="8. 多目标扩展"></a>8. 多目标扩展</h3><ol><li>语法<code>&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt; &lt;commands&gt;</code></li><li>例子<ol><li>目标从$object中获取</li><li>“%.o”表明要所有以”.o”结尾的目标，即”foo.o bar.o”，就是变量$object集合的模式</li><li>依赖模式”%.c”则取模式”%.o”的”%”，也就是”foo bar”，并为其加下”.c”的后缀，于是依赖的目标就是”foo.c bar.c”</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line">all: $(objects)</span><br><span class="line">$(objects): %.o: %.c</span><br><span class="line">  $(CC) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line"># 等价于如下</span><br><span class="line">foo.o : foo.c</span><br><span class="line">  $(CC) -c $(CFLAGS) foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">  $(CC) -c $(CFLAGS) bar.c -o bar.o</span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><ol><li>编写方法：<ol><li>遍历.c文件中的头文件依赖树，把每一个依赖的头文件都放到后面！gcc里面有参数。</li><li>不写.h的话：第一次编译连接不会有问题，但是若头文件发生更新，并不会重新编译</li></ol></li><li>多目标扩展<ol><li>语法：<code>&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;&lt;commands&gt;...</code></li><li>举例</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line">all: $(objects)</span><br><span class="line">$(objects): %.o: %.</span><br><span class="line">   c$(CC) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><ol><li>目标从$object中获取</li><li>“%.o”表明要所有以”.o”结尾的目标，即”foo.o bar.o”，就是变量$object集合的模式</li></ol><ul><li>依赖模式”%.c”则取模式”%.o”的”%”，也就是”foo bar”，并为其加下”.c”的后缀，于是依赖的目标就是”foo.c bar.c”</li></ul><p>上述规则等价于</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c$(CC) -c $(CFLAGS) foo.c -o foo.o</span><br><span class="line"></span><br><span class="line">bar.o : bar.c$(CC) -c $(CFLAGS) bar.c -o bar.o </span><br><span class="line"></span><br><span class="line">MAKEFILE</span><br></pre></td></tr></table></figure><h3 id="9-调用语法"><a href="#9-调用语法" class="headerlink" title="9.调用语法"></a>9.调用语法</h3><ol><li><ol><li><code>$(&lt;function&gt; &lt;arguments&gt;)</code></li><li><code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code></li></ol></li><li>字符串处理函数<ol><li><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></li><li><code>$(strip &lt;string&gt;)</code></li></ol></li><li>文件名操作函数<ol><li><code>$(dir &lt;names...&gt;)</code></li><li><code>$(basename &lt;names...&gt;)</code></li></ol></li><li>foreach 函数<ol><li><code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></li></ol></li><li>if 函数<ol><li><code>$(if &lt;condition&gt;,&lt;then-part&gt;)</code></li><li><code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></li></ol></li><li>call函数<ol><li><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code></li></ol></li></ol><h1 id="五、linux程序文件系统"><a href="#五、linux程序文件系统" class="headerlink" title="五、linux程序文件系统"></a>五、linux程序文件系统</h1><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143751091.png" alt="image-20230525143751091"></p><h2 id="1-文件系统的多种含义"><a href="#1-文件系统的多种含义" class="headerlink" title="1.文件系统的多种含义"></a>1.文件系统的多种含义</h2><ol><li>文件系统：Linux内核源代码情景分析，P415<ol><li>指种特定的文件格式。例如，我们说Linux的文件系统是Ext2, MSDOS的文件系统是FATI6，而Windows NT的文件系统是NTFS或FAT32,就是指这个意思。</li><li>指按特定格式进行了”格式化”的块存储介质。当我们说”安装”或”拆卸”一个文件系统时，指的就是这个意思。</li><li>指操作系统中(通常在内核中)用来管理文件系统以及对文件进行操作的机制及其实现，这就是本章的主要话题。</li></ol></li></ol><h2 id="2-文件类型和结构"><a href="#2-文件类型和结构" class="headerlink" title="2. 文件类型和结构"></a>2. 文件类型和结构</h2><ol><li>文件类型<ol><li>常规文件</li><li>字符专用文件</li><li>特殊块文件</li><li>fifo</li><li>socket</li><li>符号链接</li><li>目录</li></ol></li><li>文件结构<ol><li>字节流； 没有特别的内部结构</li></ol></li></ol><h2 id="3-Liunx中的文件系统"><a href="#3-Liunx中的文件系统" class="headerlink" title="3. Liunx中的文件系统"></a>3. Liunx中的文件系统</h2><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143802267.png" alt="image-20230525143802267"></p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143818429.png" alt="image-20230525143818429"></p><h3 id="1-VFS模型-考试要考"><a href="#1-VFS模型-考试要考" class="headerlink" title="1. VFS模型(考试要考)"></a>1. VFS模型(考试要考)</h3><p><strong>工作方式</strong>：</p><p>用户写入一个文件，使用POSIX标准的write接口，会被操作系统接管，转调sys_write这个系统调用（属于SCI层）。然后VFS层接受到这个调用，通过自身抽象的模型，转换为对给定文件系统、给定设备的操作，这一关键性的步骤是VFS的核心，需要有统一的模型，使得对任意支持的文件系统都能实现系统的功能。这就是VFS提供的统一的文件模型（common file model），底层具体的文件系统负责具体实现这种文件模型，负责完成POSIX API的功能，并最终实现对物理存储设备的操作。</p><ol><li><p>虚拟; 仅存在于内存中</p></li><li><p>组件：</p><ol><li><p>超级块(super block):某一个磁盘的某一个分区的文件系统的信息</p><ol><li>记录文件系统类型</li><li>记录文件系统的参数</li></ol></li><li><p>i节点对象(i-node object):index</p><ol><li>记录的是真正的文件，文件存储在磁盘上时是按照索引号访问文件的</li></ol></li><li><p>文件对象(file object)</p><ol><li>记录的是文件描述符，索引号</li><li>不对应真正的文件，文件open后会创建出文件对象。</li><li>文件没有close，则内核中的文件对象就没有释放</li></ol></li><li><p>目录对象(dentry object)</p><p>dentry没有在磁盘等底层持久化存储设备上存储，是一个动态创建的内存数据结构，主要是为了构建出树状组织结构而设计，用来进行文件、目录的查找。dentry创建之后会被操作系统进行缓存，目的是为了提升对文件系统进行操作的性能。dentry的结构如下示意，具体定义于“&lt;linux&#x2F;dcache.h&gt;”。</p></li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143831431.png" alt="image-20230525143831431"></p><h3 id="2-Ext2-文件系统"><a href="#2-Ext2-文件系统" class="headerlink" title="2. Ext2 文件系统"></a>2. Ext2 文件系统</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143850805.png" alt="image-20230525143850805"></p><h3 id="3-硬链接和符号链接"><a href="#3-硬链接和符号链接" class="headerlink" title="3. 硬链接和符号链接"></a>3. 硬链接和符号链接</h3><ol><li>Hard link<ol><li>不同的文件名对应同一个inode</li><li>不能跨越文件系统</li><li>对应系统调用link</li></ol></li><li>Symbolic link<ol><li>存储被链接文件的文件名(而不是inode)实现链接</li><li>可跨越文件系统</li><li>对应系统调用symlink</li></ol></li></ol><h3 id="4-回顾命令：ls-l"><a href="#4-回顾命令：ls-l" class="headerlink" title="4. 回顾命令：ls -l"></a>4. 回顾命令：<code>ls -l</code></h3><ol><li>为了显示文件的可访问权限，我们在使用ls命令的时候同时使用-l参数</li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143910304.png" alt="image-20230525143910304"></p><h3 id="5-系统调用和库函数"><a href="#5-系统调用和库函数" class="headerlink" title="5. 系统调用和库函数"></a>5. 系统调用和库函数</h3><ol><li><p>都以C函数的形式出现</p></li><li><p>系统调用</p><ol><li>Linux内核的对外接口; 用户程序和内核之间唯一的接口; 提供最小接口</li></ol></li><li><p>库函数</p><ol><li>依赖于系统调用; 提供较复杂功能</li><li>例：标准I&#x2F;O库</li></ol></li><li><p>无缓冲I&#x2F;O和缓冲I&#x2F;O</p></li><li><p>无缓冲I&#x2F;O</p><ol><li>读写 -&gt; 系统调用</li><li>文件描述符</li><li>并不是ANSI C，而是POSIX.1 和 XPG3</li></ol></li><li><p>缓冲I&#x2F;O</p><ol><li>通过标准I&#x2F;O库来实现</li><li>处理很多细节，比如缓存分配</li><li>流 -&gt; 指向FILE的指针</li></ol></li></ol><h3 id="6-标准I-O系统调用"><a href="#6-标准I-O系统调用" class="headerlink" title="6.标准I&#x2F;O系统调用"></a>6.标准I&#x2F;O系统调用</h3><ol><li>文件描述符</li><li>标准I&#x2F;O<ol><li>open&#x2F;creat, close, read, write, lseek</li><li>dup&#x2F;dup2</li><li>fcntl</li><li>ioctl</li></ol></li></ol><h4 id="1-文件描述符"><a href="#1-文件描述符" class="headerlink" title="1. 文件描述符"></a>1. 文件描述符</h4><ol><li>文件描述符<ol><li>一个小的非负整数：<code>int fd</code>;</li><li>在&lt;unistd.h&gt;中<ol><li>STDIN_FILENO(0)，STDOUT_FILENO(1)，STDERR_FILENO(2)</li></ol></li></ol></li><li>文件操作的一般步骤：open - read&#x2F;write - [lseek] - close</li></ol><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* a rudimentary example program */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()&#123;</span><br><span class="line">   <span class="type">int</span> fd, nread;</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">1024</span>]; <span class="comment">// 打开一个字节的内容来打开文件</span></span><br><span class="line">   <span class="comment">/*open file &quot;data&quot; for reading */</span></span><br><span class="line">   fd = <span class="built_in">open</span>(<span class="string">&quot;data&quot;</span>, O_RDONLY); <span class="comment">// 系统调用C++中使用的fopen，返回文件描述符，一般返回3</span></span><br><span class="line">   <span class="comment">/* read in the data */</span></span><br><span class="line">   nread = <span class="built_in">read</span>(fd, buf, <span class="number">1024</span>);<span class="comment">// 关闭的时候也用文件描述符关闭，释放句柄</span></span><br><span class="line">   <span class="comment">/* close the file */</span></span><br><span class="line">   <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-open-creat-函数"><a href="#3-open-creat-函数" class="headerlink" title="3. open&#x2F;creat 函数"></a>3. open&#x2F;creat 函数</h4><ol><li>打开和建立一个文件或设备</li><li>C语言不能够重载，为什么会有2个open？并不是通过重载实现的，两个open是以一个函数的形式提供的，C语言提供了变长参数的函数机制。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> <span class="comment">// sys:linux系统下提供的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// open 也可以创建文件，覆盖了creat的所有功能</span></span><br><span class="line"><span class="comment">// pathname 含路径的文件名</span></span><br><span class="line"><span class="comment">// flags 标志位，是一串二进制数字，可以进行按位或哦，所以是int类型</span></span><br><span class="line"><span class="comment">// mode 文件权限</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 创建文件的系统调用接口</span></span><br><span class="line"><span class="comment">// flag 给默认为只写O_WRONLY和清零O_TRUNC</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// (Return: a new file descriptor if success; -1 if failure)</span></span><br></pre></td></tr></table></figure><ol><li><h5 id="参数-flag"><a href="#参数-flag" class="headerlink" title="参数 flag"></a>参数 flag</h5></li><li><p>“标志”：文件访问方式</p><ol><li>O_RDONLY，O_WRONLY或O_RDWR中的一个请求分别按以下方式对文件进行只读，只读或读&#x2F;写操作，这些操作按零或多个进行按或运算：（全部在&#x2F;usr&#x2F;include&#x2F;fcntl.h中定义 ）<ol><li>O_APPEND：以附加模式打开文件</li><li>O_TRUNC：如果文件已经存在并且是常规文件，并且打开方式允许写入，则会将其长度截断为0。</li><li>O_CREAT：如果文件不存在，将创建它。</li><li>O_EXCL：与O_CREAT一起使用时，如果文件已存在，则为错误，打开失败。</li></ol></li></ol></li><li><p>“创建”功能：相当于以等于O_CREAT | O_WRONLY | O_TRUNC的标志打开</p></li><li><p>使用<code>|</code>来分割多个参数</p></li></ol><h4 id="4-参数-mode"><a href="#4-参数-mode" class="headerlink" title="4. 参数 mode"></a>4. 参数 mode</h4><ol><li>mode：指定在创建新文件的情况下使用的权限。</li><li>取值情况</li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143929956.png" alt="image-20230525143929956"></p><ol><li><p>需要多个权限的话，也是按位或。<code>S_IRUSR|S_IWUSR</code>就表示<code>rw-</code>。</p></li><li><p>注意这里的权限是<strong>4位八进制数</strong>。</p></li><li><p>mode参数和umask</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@RedHat8-2 ~]# umask</span><br><span class="line">0022</span><br><span class="line">[root@RedHat8-2 ~]# umask -S</span><br><span class="line">u=rwx,g=rx,o=rx</span><br><span class="line"> </span><br><span class="line">[root@RedHat8-2 ~]# su - stu10</span><br><span class="line">Last login: Fri Jun 11 14:05:19 CST 2021 on pts/0</span><br><span class="line">[stu10@RedHat8-2 ~]$ umask</span><br><span class="line">0002</span><br><span class="line">[stu10@RedHat8-2 ~]$ umask -S</span><br><span class="line">u=rwx,g=rwx,o=rx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. *root*：目录 777-022=755</span><br><span class="line">2. *root*：文件 666-022=644</span><br><span class="line">3. *stu10*：目录 777-002=775</span><br><span class="line">4. *stu10*: 文件 666-002=664</span><br></pre></td></tr></table></figure><ol><li>umask：文件保护机制</li><li>新文件的初始访问方式<ol><li>mode和~umask</li></ol></li></ol><h4 id="5-close-函数"><a href="#5-close-函数" class="headerlink" title="5. close 函数"></a>5. close 函数</h4><ol><li>选择一个文件描述符</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">//(Return: 0 if success; -1 if failure)</span></span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>注意<strong>打开的文件一定要关闭</strong></li></ol><h4 id="6-read-write-函数"><a href="#6-read-write-函数" class="headerlink" title="6. read&#x2F;write 函数"></a>6. read&#x2F;write 函数</h4><ol><li>Read from a file descriptor</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">//(返回值: 读到的字节数，若已到文件尾为0，若出错为-1)</span></span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>Write to a file descriptor</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">//(返回值: 若成功为已写的字节数，若出错为-1)</span></span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>例子</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((n = <span class="built_in">read</span>(STDIN_FILENO, buf, BUFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">      <span class="built_in">err_sys</span>(<span class="string">&quot;write‏error&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">      <span class="built_in">err_sys</span>(<span class="string">&quot;read‏error&quot;</span>);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="7-lseek函数"><a href="#7-lseek函数" class="headerlink" title="7. lseek函数"></a>7. lseek函数</h4><ol><li>重定义读写文件偏移量</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">off_t</span> <span class="title">lseek</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span></span>;</span><br><span class="line"><span class="comment">// (Return: the resulting offset location if success; -1 if failure)</span></span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>The‏directive‏”whence”:<ol><li>SEEK_SET:‏the‏ offset ‏is‏ set‏ to‏ “offset” ‏bytes</li><li>SEEK_CUR: the offset is set to its current location plus “offset”‏bytes</li><li>SEEK_END:‏the‏offset‏if‏set‏to‏the‏size‏of‏the‏file‏plus‏”offset”‏ bytes</li></ol></li></ol><h4 id="8-dup-dup2函数"><a href="#8-dup-dup2函数" class="headerlink" title="8. dup&#x2F;dup2函数"></a>8. dup&#x2F;dup2函数</h4><ol><li>Duplicate a file descriptor</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">//(Return: the new file descriptor if success; -1 if failure)</span></span><br></pre></td></tr></table></figure><ol><li>File sharing，Example: <strong>redirection</strong></li><li>用在重定向中<ol><li>ls：本质就是对1号文件描述符写数据(无论是printf还是cout)</li><li>将原来1号文件描述符从控制台输出转到其他文件中</li><li>打开一个文件，就会有一个文件描述符(例如是3号文件描述符)，使用dup2系统调用，就可以实现了。</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dup2</span>(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">fd=<span class="built_in">open</span>(<span class="string">&quot;aaa.txt&quot;</span>, ...);</span><br><span class="line"><span class="built_in">dup2</span>(fd, <span class="number">1</span>);<span class="comment">//使用打开文件的文件描述符覆盖1号的，进行重定向</span></span><br><span class="line"><span class="built_in">dup</span>(<span class="number">1000</span>, <span class="number">1</span>);<span class="comment">//当重定向好了之后将1000号覆盖掉1号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-fcntl-函数"><a href="#9-fcntl-函数" class="headerlink" title="9. fcntl 函数"></a>9. fcntl 函数</h4><ol><li>Manipulate a file descriptor</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd);</span><br><span class="line">int fcntl(int fd, int cmd, long arg);</span><br><span class="line">int fcntl(int fd, int cmd, struct flock *lock);//可以对文件加锁</span><br><span class="line">//(返回值: 若成功则依赖于cmd，若出错为-1)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>The‏ operation‏ is‏ determined ‏by‏”cmd”.</li><li>The‏ value‏ of‏”cmd”<ol><li><strong>F_DUPFD</strong>: Duplicate a file descriptor</li><li><strong>F_GETFD&#x2F;F_SETFD</strong>:‏Get&#x2F;set ‏the‏ file‏d escriptor’s<strong>‏close-on exec</strong> flag：执行时是否关闭，文件描述符能否从父进程传递到子进程。</li><li><strong>F_GETFL&#x2F;F_SETFL</strong>:‏Get&#x2F;set ‏the‏ file ‏descriptor’s <strong>‏flags</strong>(并不是所有情况都可以setfl的)</li><li><strong>F_GETOWN&#x2F;F_SETOWN</strong>: Manage I&#x2F;O availability signals(告诉当前进程是否I&#x2F;O传来的信号)(不要求理解深刻)</li><li><strong>F_GETLK&#x2F;F_SETLK&#x2F;F_SETLKW</strong>: Get&#x2F;set the file lock(暂时不讲)</li></ol></li><li>Example：dup&#x2F;dup2 and fcntl</li><li>fcntl对于文件描述符的操作很全面</li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525143947303.png" alt="image-20230525143947303"></p><ol><li>pid保存进程id(可以理解为int类型，linux下做了类型的重定义)</li><li><code>if(fd == -1)</code>：异常处理(文件打开失败)</li><li><code>fcntl(fd, F_SETFD, 1);</code>这里将<strong>close-on-exec</strong> flag设置为true，所以<strong>调用execl的时候，fd会关闭</strong>。</li><li><code>fork()</code>：Linux下很特别的系统调用，是用来创建进程的；复制一份父进程，作为父进程的子进程。(注意：被启动的子进程，就从fork()之后继续执行；子进程并不重复执行，某种程度上子进程和父进程是完全一样的；只有fork()系统调用的返回值不一样)</li><li>父进程fork()函数的返回值就是子进程的pid，而子进程fork()函数的返回值是0。</li><li>子进程是复制了父进程，所以这里子进程有fd这个文件描述符。</li><li>exec系列函数的使用<ol><li><strong>用另外一个程序代替当前进程，不会新开进程</strong>(用当前进程执行新的程序)</li><li>启动一段新的程序，将新程序的内存覆盖掉当前进程的内存。</li><li>如果没有fork就执行execl，则当前shell的进程没有了(呗新的程序占用了)</li></ol></li><li>注意：<ol><li>这里是<code>pid==0</code>，才会执行execl。所以是<strong>子进程执行了这个execl</strong>。</li><li><code>execl(&quot;ass&quot;, &quot;./ass&quot;, &amp;fd, NUKK)</code>：传递的是fd所在地址，这里是int类型的地址，而execl函数要求的传输类型是char类型的地址，所以这里是类型转换。(但是这里的fd的值不能太大，因为是按照char类型读取的，所以fd的值在128以内应该没有问题)</li><li><code>wait(NULL)</code>：父进程就在这里等待，知道子进程执行完ass</li><li>最后的执行结果：test.txt文件中只会有”ooooo”，不会有”zzzzz”</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525144010245.png" alt="image-20230525144010245"></p><h4 id="10-ioctl-Function"><a href="#10-ioctl-Function" class="headerlink" title="10. ioctl Function"></a>10. ioctl Function</h4><ol><li>Control devices</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ioctl</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><p>更改一种特殊类型的文件(块类型和字符类型的设备)</p><p>request:根据文件类型（设备类型）自身协议等不同，包括开启，关闭。。</p></li></ol><h2 id="7-标准I-O库"><a href="#7-标准I-O库" class="headerlink" title="7. 标准I&#x2F;O库"></a>7. 标准I&#x2F;O库</h2><ol><li>文件系统</li><li>标准I&#x2F;O函数</li></ol><h3 id="1-文件流"><a href="#1-文件流" class="headerlink" title="1. 文件流"></a>1. 文件流</h3><ol><li><p>流和文件结构</p><ol><li><code>FILE * fp;</code></li><li>预定义指针：<code>stdin, stdout, stderr</code>(封装了012号文件描述符)</li></ol></li><li><p>缓冲I&#x2F;O</p><ol><li><p>三类缓冲区</p><p>全缓存：当填满标准I&#x2F;O缓存后才执行I&#x2F;O操作，磁盘上的文件通常是全缓存的。</p><p>行缓存：当输入输出遇到新行符或缓存满时，才由标准I&#x2F;O库执行实际I&#x2F;O操作，stdin、stdout通常是行缓存的。</p><p>无缓存：相当于read、write了，stderr通常是无缓存的，因为它必须尽快输出。</p></li><li><p>setbuf&#x2F;setvbuf函数</p></li></ol></li></ol><h3 id="2-流缓冲操作"><a href="#2-流缓冲操作" class="headerlink" title="2. 流缓冲操作"></a>2. 流缓冲操作</h3><ol><li>三种缓冲<ol><li>块缓冲（完全缓冲）</li><li>线缓冲</li><li>无缓冲</li></ol></li><li>setbuf，setvbuf函数</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 如果引入的是标准库，就不是系统调用，系统调用的输入参数一般是文件描述符而不是流指针</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream，<span class="type">char</span> * buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream，<span class="type">char</span> * buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span></span>; <span class="comment">// 类型: _IOFBF 满缓冲 _IOLBF 行缓冲 _IONBF 无缓冲</span></span><br></pre></td></tr></table></figure><ol><li>补充：<ol><li>setbuf用于打开或关闭流缓冲机制，参数buf指向一个长度为BUFSIZ（该常量在<code>&lt;stdio.h&gt;</code>中定义）的缓冲区；如果要关闭缓冲，则将buf设置为NULL即可。</li><li>setvbuf用于精确地设置所需的缓冲类型，mode取值如下：_IOFBF(全缓冲)&#x2F;_IOLBF(行缓冲)&#x2F;_IONBF(无缓冲)；如果指定了mode为带缓冲类型，而buf却为NULL，则系统会自动分配BUFSIZ个字节的缓冲区。</li></ol></li></ol><h3 id="3-标准I-O函数"><a href="#3-标准I-O函数" class="headerlink" title="3. 标准I&#x2F;O函数"></a>3. 标准I&#x2F;O函数</h3><ol><li>Stream open&#x2F;close</li><li>Stream read&#x2F;write<ol><li>每次一个字符的I&#x2F;O</li><li>每次一行的I&#x2F;O</li><li>直接I&#x2F;O(二进制I&#x2F;O)</li><li>格式化I&#x2F;O</li></ol></li><li>Stream reposition</li><li>Stream flush</li></ol><h4 id="10-4-6-1-Stream-open-close"><a href="#10-4-6-1-Stream-open-close" class="headerlink" title="10.4.6.1. Stream open&#x2F;close"></a>10.4.6.1. Stream open&#x2F;close</h4><ol><li>Open a stream</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>Parameter‏”mode”<ol><li>“r”: Open text file for <strong>reading</strong>.</li><li>“w”: Truncate file to zero length or create text file for writing.</li><li>“a”: Open for <strong>appending</strong>(追加).</li><li>“r+”: Open for <strong>reading and writing</strong>.</li><li>“w+”: Open for reading and writing. The file is created if it does not exist, <strong>otherwise it is truncated</strong>.</li><li>“a+”: Open for <strong>reading and appending</strong>. The file is created if does not exist.</li></ol></li><li>Close a stream</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br><span class="line"><span class="comment">// (Return: 0 if success; -1 if failure)</span></span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-6-2-输入字符"><a href="#10-4-6-2-输入字符" class="headerlink" title="10.4.6.2. 输入字符"></a>10.4.6.2. 输入字符</h4><ol><li>getc, fgetc, getchar functions</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int getc(FILE *fp);</span><br><span class="line">int fgetc(FILE *fp);</span><br><span class="line">int getchar(void);</span><br><span class="line">// (Result: Reads the next character from a stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>Three functions:ferror, feof, clearerr</li><li>ungetc function: push a character back to a stream.</li></ol><h4 id="10-4-6-3-输出字符"><a href="#10-4-6-3-输出字符" class="headerlink" title="10.4.6.3. 输出字符"></a>10.4.6.3. 输出字符</h4><ol><li>putc, fputc, putchar functions</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int putc(int c, FILE *fp);</span><br><span class="line">int fputc(int c, FILE *fp);</span><br><span class="line">int putchar(int c);</span><br><span class="line">// (Return: the character if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-6-4-一行字符串输入"><a href="#10-4-6-4-一行字符串输入" class="headerlink" title="10.4.6.4. 一行字符串输入"></a>10.4.6.4. 一行字符串输入</h4><ol><li>fgets, gets functions</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char *fgets(char *s, int size, FILE *stream);</span><br><span class="line">char *gets(char *s); //not recommended.</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>fgets: reads in at most <strong>size-1</strong> characters from stream and stores them into the buffer pointed by s. <strong>Reading stops after an EOF or a new line</strong>. A “\0” character is stored at the end of the buffer</li></ol><h4 id="10-4-6-5-一行字符串输出"><a href="#10-4-6-5-一行字符串输出" class="headerlink" title="10.4.6.5. 一行字符串输出"></a>10.4.6.5. 一行字符串输出</h4><ol><li>fputs, puts functions</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fputs(const char *s, FILE *stream);</span><br><span class="line">int puts(const char *s);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h3 id="10-4-7-Question-I-O-Efficiency"><a href="#10-4-7-Question-I-O-Efficiency" class="headerlink" title="10.4.7. Question: I&#x2F;O Efficiency"></a>10.4.7. Question: I&#x2F;O Efficiency</h3><ol><li>Rewrite mycat.c<ol><li>read&#x2F;write version</li><li>getc&#x2F;putc version</li><li>fgetc&#x2F;fputc version</li><li>fgets&#x2F;fputs version</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;ourhdr.h&quot;</span><br><span class="line"></span><br><span class="line">#define BUFFSIZE 8192</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">   int n;</span><br><span class="line">   char buf[BUFFSIZE];</span><br><span class="line">   </span><br><span class="line">   while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0)&#123;</span><br><span class="line">      if(write(STDOUT_FILENO, buf, n) != n)&#123;</span><br><span class="line">         err_sys(&quot;write error&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if(n &lt; 0)&#123;</span><br><span class="line">      err_sys(&quot;read error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525144028112.png" alt="image-20230525144028112"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;ourhdr.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">   int c;</span><br><span class="line">   while((c = getc(stdin)) != EOF)&#123;</span><br><span class="line">      if(putc(c, stdout) == EOF)&#123;</span><br><span class="line">         err_sys(&quot;output error&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if(ferror(stdin))&#123;</span><br><span class="line">      err_sys(&quot;input error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525144043116.png" alt="image-20230525144043116"></p><h4 id="10-4-7-1-二进制流输入-输出"><a href="#10-4-7-1-二进制流输入-输出" class="headerlink" title="10.4.7.1. 二进制流输入&#x2F;输出"></a>10.4.7.1. 二进制流输入&#x2F;输出</h4><ol><li>fread&#x2F;fwrite functions</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br><span class="line">size fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br><span class="line">//(Return: the number of a items successfully read or written.)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>Application:<ol><li>Read&#x2F;write a binary array:</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float data[10];</span><br><span class="line">if ( fwrite(&amp;data[2], sizeof(float), 4, fp) != 4 )</span><br><span class="line">   err_sys(&quot;fwrite‏error&quot;);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>Read&#x2F;write a structure</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   short count; long total; char name[NAMESIZE];</span><br><span class="line">&#125;item;</span><br><span class="line">if ( fwrite(&amp;item, sizeof(item), 1, fp) != 1)</span><br><span class="line">   err_sys(&quot;fwrite‏error&quot;);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-2-格式化I-O"><a href="#10-4-7-2-格式化I-O" class="headerlink" title="10.4.7.2. 格式化I&#x2F;O"></a>10.4.7.2. 格式化I&#x2F;O</h4><ol><li>scanf, fscanf, sscanf functions</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int scanf(const char *format, ...);</span><br><span class="line">int fscanf(FILE *stream, const char *format, ...);</span><br><span class="line">int sscanf(const char *str, const char *format, ...);// 将str所指向的字符串，按照format进行提取</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>使用可变参数，可以解决C语言没有重载的问题。</li><li>Use fgets, then parse the string.</li><li>printf, fprintf, sprintf functions</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int printf(const char *format, ...);</span><br><span class="line">int fprintf(FILE *stream, const char *format, ...);</span><br><span class="line">int sprintf(char *str, const char *format, ...);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-3-Reposition-a-stream"><a href="#10-4-7-3-Reposition-a-stream" class="headerlink" title="10.4.7.3. Reposition a stream"></a>10.4.7.3. Reposition a stream</h4><ol><li>fseek, ftell, rewind functions</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fseek(FILE *stream, long int offset, int whence);</span><br><span class="line">long ftell(FILE *stream);</span><br><span class="line">void rewind(FILE *stream);</span><br><span class="line">// 使用文件指针的一定是C语言，而不是系统调用</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>fgetpos, fsetpos functions ( Introduced in ANSI C)</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fgetpos(FILE *fp, fpos_t *pos);</span><br><span class="line">int fsetpos(FILE *fp, const fpos_t *pos);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-4-Flush-a-stream"><a href="#10-4-7-4-Flush-a-stream" class="headerlink" title="10.4.7.4. Flush a stream"></a>10.4.7.4. Flush a stream</h4><ol><li>刷新文件流。把流里的数据立刻写入文件</li><li>注意使用打印定位错误的时候可能由于没有及时刷新无法定位</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fflush(FILE *stream);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-5-Stream-and-File-Descriptor"><a href="#10-4-7-5-Stream-and-File-Descriptor" class="headerlink" title="10.4.7.5. Stream and File Descriptor"></a>10.4.7.5. Stream and File Descriptor</h4><ol><li>确定流使用的底层文件描述符</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fileno(FILE *fp);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>根据已打开的文件描述符创建一个流</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *fdopen(int fildes, const char *mode);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-6-Temporary-File"><a href="#10-4-7-6-Temporary-File" class="headerlink" title="10.4.7.6. Temporary File"></a>10.4.7.6. Temporary File</h4><ol><li>Create a name for a temporary file</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char *tmpnam(char *s);</span><br><span class="line">//(返回值: 指向唯一路径名的指针)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>Create a temporary file</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *tmpfile(void);</span><br><span class="line">//(返回值: 若成功为文件指针，若出错为NULL)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-7-Advanced-System-Calls"><a href="#10-4-7-7-Advanced-System-Calls" class="headerlink" title="10.4.7.7. Advanced System Calls"></a>10.4.7.7. Advanced System Calls</h4><ol><li>Handling file attributes<ol><li>stat&#x2F;fstat&#x2F;lstat, …</li></ol></li><li>Handling directory</li></ol><h4 id="10-4-7-8-stat-fstat-lstat-functions"><a href="#10-4-7-8-stat-fstat-lstat-functions" class="headerlink" title="10.4.7.8. stat&#x2F;fstat&#x2F;lstat functions"></a>10.4.7.8. stat&#x2F;fstat&#x2F;lstat functions</h4><ol><li>Get file status</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int stat(const char *filename, struct stat *buf);</span><br><span class="line">int fstat(int filedes, struct stat *buf);</span><br><span class="line">int lstat(const char *file_name, struct stat *buf);</span><br><span class="line">//(Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-9-struct-stat"><a href="#10-4-7-9-struct-stat" class="headerlink" title="10.4.7.9. struct stat"></a>10.4.7.9. struct stat</h4><ol><li>文件属性，实际Linux系统中的结构体字段可能有所不同。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct stat &#123;</span><br><span class="line">   mode_t st_mode; /*file type &amp; mode 权限和文件类型(Linux 系统中的文件类型)*/</span><br><span class="line">   ino_t st_ino; /*inode number (serial number)*/</span><br><span class="line">   dev_t st_rdev; /*device number (file system) 指向设备时字段有意义*/</span><br><span class="line">   nlink_t st_nlink; /*link count 硬链接计数*/</span><br><span class="line">   uid_t st_uid; /*user ID of owner*/</span><br><span class="line">   gid_t st_gid; /*group ID of owner*/</span><br><span class="line">   off_t st_size; /*size of file, in bytes*/</span><br><span class="line">   time_t st_atime; /*time of last access*/</span><br><span class="line">   time_t st_mtime; /*time of last modification*/</span><br><span class="line">   time_t st_ctime; /*time of last file status change*/</span><br><span class="line">   long st_blksize; /*Optimal block size for I/O*/</span><br><span class="line">   long st_blocks; /*number 512-byte blocks allocated*/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-10-Test-macros-for-file-types"><a href="#10-4-7-10-Test-macros-for-file-types" class="headerlink" title="10.4.7.10. Test macros for file types"></a>10.4.7.10. Test macros for file types</h4><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525144055691.png" alt="image-20230525144055691"></p><h4 id="10-4-7-11-File-Permission-Basics"><a href="#10-4-7-11-File-Permission-Basics" class="headerlink" title="10.4.7.11. File Permission - Basics"></a>10.4.7.11. File Permission - Basics</h4><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525144109588.png" alt="image-20230525144109588"></p><h4 id="10-4-7-12-Deep-into-SUID-SGID-Sticky-bit"><a href="#10-4-7-12-Deep-into-SUID-SGID-Sticky-bit" class="headerlink" title="10.4.7.12. Deep into SUID, SGID, Sticky bit"></a>10.4.7.12. Deep into SUID, SGID, Sticky bit</h4><ol><li>用来提高权限，SUID将用户提升到root权限，SGID将group提升到root</li><li>Authorization in a Linux system is based on file permissions</li><li>An SUID or SGID bit on a program elevates your authorization level while running that program to the authorization level of the owner of that program</li><li>Typical SUID&#x2F;SGID programs are su and sudo</li></ol><h4 id="10-4-7-13-File-permission-第一个0表示八进制"><a href="#10-4-7-13-File-permission-第一个0表示八进制" class="headerlink" title="10.4.7.13. File permission(第一个0表示八进制)"></a>10.4.7.13. File permission(第一个0表示八进制)</h4><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230525144119825.png" alt="image-20230525144119825"><br><img src="/../../AppData/Roaming/Typora/typora-user-images/image-20230525144132186.png" alt="image-20230525144132186"></p><h4 id="10-4-7-14-获取权限"><a href="#10-4-7-14-获取权限" class="headerlink" title="10.4.7.14. 获取权限"></a>10.4.7.14. 获取权限</h4><ol><li>按<strong>实际用户ID和实际组ID</strong>测试文件存取权限</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int access(const char *pathname, int mode);</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>Parameter‏”mode”：R_OK(可读), W_OK(可写), X_OK(可执行), F_OK(可见)</li></ol><h4 id="10-4-7-15-chmod-fchmod-functions"><a href="#10-4-7-15-chmod-fchmod-functions" class="headerlink" title="10.4.7.15. chmod&#x2F;fchmod functions"></a>10.4.7.15. chmod&#x2F;fchmod functions</h4><ol><li>Change permissions of a file</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int chmod(const char *path, mode_t mode);</span><br><span class="line">int fchmod(int fildes, mode_t mode);</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-16-chown-fchown-lchown-functions"><a href="#10-4-7-16-chown-fchown-lchown-functions" class="headerlink" title="10.4.7.16. chown&#x2F;fchown&#x2F;lchown functions"></a>10.4.7.16. chown&#x2F;fchown&#x2F;lchown functions</h4><ol><li>Change ownership of a file</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int chown(const char *path, uid_t owner, gid_t group);</span><br><span class="line">int fchown(int fd, uid_t owner, gid_t group);</span><br><span class="line">int lchown(const char *path, uid_t owner, gid_t group); // 修改软链接</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-17-umask-function"><a href="#10-4-7-17-umask-function" class="headerlink" title="10.4.7.17. umask function"></a>10.4.7.17. umask function</h4><ol><li>为进程设置文件存取权限屏蔽字，并返回以前的值</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">mode_t umask(mode_t mask);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-18-link-unlink-functions"><a href="#10-4-7-18-link-unlink-functions" class="headerlink" title="10.4.7.18. link&#x2F;unlink functions"></a>10.4.7.18. link&#x2F;unlink functions</h4><ol><li>Create a new link to (make a new name for) a file.</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int link(const char *oldpath, const char *newpath);// newpath是软连接文件名</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>Delete a name and possibly the file it refers to.</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int unlink(const char *pathname);</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-19-symlink-readlink"><a href="#10-4-7-19-symlink-readlink" class="headerlink" title="10.4.7.19. symlink&#x2F;readlink"></a>10.4.7.19. symlink&#x2F;readlink</h4><ol><li>Create a symbolic link (named newpath which contains‏ the ‏string‏ “oldpath”)</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int symlink(const char *oldpath, const char *newpath);</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>Read value of a symbolic link</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int readlink(const char *path, char *buf, size_t bufsiz);</span><br><span class="line">// (Return: the count of characters placed in the buffer if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-20-Handling-directories"><a href="#10-4-7-20-Handling-directories" class="headerlink" title="10.4.7.20. Handling directories"></a>10.4.7.20. Handling directories</h4><ol><li>mkdir&#x2F;rmdir</li><li>chdir&#x2F;fchdir, getcwd</li><li>Read a directory:一些系统调用和命令行命令并不重名<ol><li>opendir&#x2F;closedir</li><li>readdir</li><li>telldir</li><li>seekdir</li></ol></li></ol><h4 id="10-4-7-21-mkdir-rmdir-functions"><a href="#10-4-7-21-mkdir-rmdir-functions" class="headerlink" title="10.4.7.21. mkdir&#x2F;rmdir functions"></a>10.4.7.21. mkdir&#x2F;rmdir functions</h4><ol><li>创建一个空目录</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int mkdir(const char *pathname, mode_t mode);</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>删除一个空目录</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int rmdir(const char *pathname);</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-22-chdir-fchdir-functions"><a href="#10-4-7-22-chdir-fchdir-functions" class="headerlink" title="10.4.7.22. chdir&#x2F;fchdir functions"></a>10.4.7.22. chdir&#x2F;fchdir functions</h4><ol><li>Change working directory</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int chdir(const char *path);</span><br><span class="line">int fchdir(int fd);</span><br><span class="line">// (Return: 0 if success; -1 if failure)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><ol><li>当前工作目录是进程的属性，所以该函数只影响调用 chdir的进程本身:<code>cd(1) command</code></li></ol><h4 id="10-4-7-23-getcwd-function"><a href="#10-4-7-23-getcwd-function" class="headerlink" title="10.4.7.23. getcwd function"></a>10.4.7.23. getcwd function</h4><ol><li>获得当前工作目录的绝对路径</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">char *getcwd(char *buf, size_t size);</span><br><span class="line">// (返回值: 若成功则为buf，若出错则为NULL)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-24-Read-a-directory"><a href="#10-4-7-24-Read-a-directory" class="headerlink" title="10.4.7.24. Read a directory"></a>10.4.7.24. Read a directory</h4><ol><li>Data structures<ol><li>DIR(类型别名), struct dirent</li></ol></li><li>Operations<ol><li>opendir&#x2F;closedir</li><li>readdir</li><li>telldir</li><li>seekdir</li></ol></li></ol><h4 id="10-4-7-25-Data-structures"><a href="#10-4-7-25-Data-structures" class="headerlink" title="10.4.7.25. Data structures"></a>10.4.7.25. Data structures</h4><ol><li><p>DIR</p><ol><li><p>The data type of directory stream objects</p></li><li><p>in</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dirent.h&gt;</span><br></pre></td></tr></table></figure><ol><li>typedef struct __dirstream DIR;</li></ol></li></ol></li><li><p>struct dirent</p><ol><li>Directory item</li><li>Defined in <code>&lt;dirent.h&gt;</code></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ino_t d_ino; /* inode number */</span><br><span class="line">char d_name[NAME_MAX + 1]; /* file name */</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-26-Operations"><a href="#10-4-7-26-Operations" class="headerlink" title="10.4.7.26. Operations"></a>10.4.7.26. Operations</h4><ol><li>目录的打开、关闭、读、定位</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">DIR *opendir(const char *name);</span><br><span class="line">int closedir(DIR *dir);</span><br><span class="line">struct dirent *readdir(DIR *dir);</span><br><span class="line">off_t telldir(DIR *dir);// 查看当前目录项的偏移量</span><br><span class="line">void seekdir(DIR *dir, off_t offset); // 跳转至下一个目录项，可指定偏移量</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h4 id="10-4-7-27-一个目录扫描程序"><a href="#10-4-7-27-一个目录扫描程序" class="headerlink" title="10.4.7.27. 一个目录扫描程序"></a>10.4.7.27. 一个目录扫描程序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIR *dp;</span><br><span class="line">struct dirent *entry;</span><br><span class="line">if ( (dp = opendir(dir)) == NULL )</span><br><span class="line">   err_sys(…);</span><br><span class="line">while ( (entry = readdir(dp)) != NULL ) &#123;</span><br><span class="line">   lstat(entry-&gt;d_name, &amp;statbuf);</span><br><span class="line">   if ( S_ISDIR(statbuf.st_mode) )</span><br><span class="line">   …</span><br><span class="line">   else</span><br><span class="line">   …</span><br><span class="line">&#125;</span><br><span class="line">closedir(dp);</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h2 id="10-5-File-lock"><a href="#10-5-File-lock" class="headerlink" title="10.5. File lock"></a>10.5. File lock</h2><ol><li>锁起的作用<ol><li>几个进程同时操作一个文件</li><li>比如多个记事本同时编辑一个文件</li></ol></li><li>锁放在哪里<ol><li>理论</li><li>实践</li></ol></li></ol><h3 id="10-5-1-文件锁分类"><a href="#10-5-1-文件锁分类" class="headerlink" title="10.5.1. 文件锁分类"></a>10.5.1. 文件锁分类</h3><ol><li>记录锁</li><li>劝告锁<ol><li>检查，加锁有应用程序自己控制</li></ol></li><li>强制锁<ol><li>检查，加锁由内核控制</li><li>影响[open() read() write()]等</li></ol></li><li>共享锁：读锁</li><li>排他锁：写锁</li></ol><h3 id="10-5-2-特殊类型"><a href="#10-5-2-特殊类型" class="headerlink" title="10.5.2. 特殊类型"></a>10.5.2. 特殊类型</h3><ol><li>共享模式强制锁：锁上加一些规则，什么规则可以做，什么规则不可以做</li><li>租借锁</li></ol><h3 id="10-5-3-标志位"><a href="#10-5-3-标志位" class="headerlink" title="10.5.3. 标志位"></a>10.5.3. 标志位</h3><ol><li>mount -o mand &#x2F;dev&#x2F;sdb7 &#x2F;mnt</li><li>super_block<ol><li>s_flags</li></ol></li><li>MS_MANDLOCK</li><li>不是所有文件系统都可以对文件加锁！</li></ol><h3 id="10-5-4-fcntl记录锁"><a href="#10-5-4-fcntl记录锁" class="headerlink" title="10.5.4. fcntl记录锁"></a>10.5.4. fcntl记录锁</h3><ol><li>用于记录锁的fcntl函数原型</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd, struct flock *lock);</span><br><span class="line">//(返回值: 若成功则依赖于cmd，若出错为-1)</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h3 id="10-5-5-struct-flock"><a href="#10-5-5-struct-flock" class="headerlink" title="10.5.5. struct flock"></a>10.5.5. struct flock</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct flock&#123;</span><br><span class="line">   ...</span><br><span class="line">   short l_type; /* Type of lock: F_RDLCK, F_WRLCK, F_UNLCK */</span><br><span class="line">   short l_whence; /* How to interpret l_start: SEEK_SET, SEEK_CUR,</span><br><span class="line">   SEEK_END */</span><br><span class="line">   off_t l_start; /* Starting offset for lock */</span><br><span class="line">   off_t l_len; /* Number of bytes to lock */</span><br><span class="line">   pid_t l_pid; /* PID of process blocking our lock (F_GETLK only) */</span><br><span class="line">   // 获得当前文件被加锁的进程ID号，只有在F_GETLK时才用</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure><h3 id="10-5-6-cmd参数"><a href="#10-5-6-cmd参数" class="headerlink" title="10.5.6. cmd参数"></a>10.5.6. cmd参数</h3><ol><li>cmd参数的取值<ol><li>F_GETLK：获得文件的封锁信息</li><li>F_SETLK：对文件的某个区域封锁或解除封锁</li><li>F_SETLKW：功能同F_SETLK, wait方式</li></ol></li></ol><h3 id="10-5-7-其它封锁命令"><a href="#10-5-7-其它封锁命令" class="headerlink" title="10.5.7. 其它封锁命令"></a>10.5.7. 其它封锁命令</h3><ol><li>lockf函数</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/file.h&gt;</span><br><span class="line">int lockf(int fd, int cmd, off_t len);</span><br><span class="line">// 怎么加锁就要怎么解锁！cmd 可以是F_ULOCK、F_LOCK、F_TLOCK(相当于fcntl的setlkw，等等！)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="/2024/09/23/jvm/"/>
      <url>/2024/09/23/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="jvm的位置"><a href="#jvm的位置" class="headerlink" title="jvm的位置"></a>jvm的位置</h2><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230526145047668.png" alt="image-20230526145047668"></p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230526145227962.png" alt="image-20230526145227962"></p><h2 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h2><p>java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</p><p>具体来说，区别为：</p><p>栈：</p><p>设计和实现更简单，适用于资源受限的系统</p><p>避开了寄存器的分配难题：使用零地址指令方式分配</p><p>大部分为零地址指令，其执行过程依赖于操作栈，指令集更小，编译器容易实现。</p><p>不需要硬件支持，可移植性更好，更好实现跨平台</p><p>寄存器：</p><p>经典的有x86的二进制指令集</p><p>指令集架构完全依赖于硬件，可移植性差</p><p>性能优秀和执行更高效</p><p>同一操作花费指令少</p><p>大部分情况下，都是一&#x2F;二&#x2F;三地址指令</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="jvm启动"><a href="#jvm启动" class="headerlink" title="jvm启动"></a>jvm启动</h3><p>通过引导类加载器(bootstrap class loader)创建一个初始类来完成（initial class），这个类由虚拟机具体实现来指定</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>一个运行中的jvm有一个清晰的任务：执行java程序</p><p>jvm随程序的执行而运行，随程序的程序而停止</p><p>执行一个java程序时，实际执行的是一个叫做java虚拟机的进程</p><h3 id="推出"><a href="#推出" class="headerlink" title="推出"></a>推出</h3><p>程序正常结束</p><p>遇到异常或错误而异常终止</p><p>os出现错误</p><p>某个线程调用runtime或system类的exit方法，或者Runtime类的halt方法，且此时java安全管理器也允许该操作</p><h1 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2.类加载子系统"></a>2.类加载子系统</h1><h2 id="（1）概述类的加载器及类加载过程"><a href="#（1）概述类的加载器及类加载过程" class="headerlink" title="（1）概述类的加载器及类加载过程"></a>（1）概述类的加载器及类加载过程</h2><p>类加载器子系统负责从文件系统或网络中加载class文件，class文件在文件开头由特定文件标识</p><p>classLoader只负责class文件的加载，具体是否可以运行，由执行引擎决定</p><p>加载的类信息存放于方法区。除了类的信息外，方法区中还会存放运行时常量池信息，可能还会包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230526153920454.png" alt="image-20230526153920454"></p><h2 id="（2）加载过程一：load"><a href="#（2）加载过程一：load" class="headerlink" title="（2）加载过程一：load"></a>（2）加载过程一：load</h2><p>1.通过一个类的全限定名获取定义此类的二进制字节流</p><p>2.将这个字节流所代表的静态存储结构转化为方法去的运行时数据结构</p><p>3.在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法去这个类的各种数据的访问入口</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230526154332046.png" alt="image-20230526154332046"></p><h2 id="（3）加载过程二：链接"><a href="#（3）加载过程二：链接" class="headerlink" title="（3）加载过程二：链接"></a>（3）加载过程二：链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保class文件中的字节流包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</p><p>主要包括四种：文件格式验证，元数据验证，字节码验证，符号引用验证</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量分配内存冰赦罪该类变量的默认初始值，即零值</p><p>这里不包含用final修饰的static，因为final在编译时就会分配了，准备阶段会显示初始化。</p><p>这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量会随着对象一起分配到java堆</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池中的符号引用转换为直接引用的过程</p><p>事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行</p><p>符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中，直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、等，对于常量池中的CONST_Class_info,CONST_Fieldref_info,CONST_Methodref_info</p><h2 id="（4）加载过程三：初始化"><a href="#（4）加载过程三：初始化" class="headerlink" title="（4）加载过程三：初始化"></a>（4）加载过程三：初始化</h2><p>执行类构造器方法<code>&lt;clint&gt;()</code>方法</p><p>此方法不需定义，由javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来。</p><p>构造器方法中指令按语句在源文件中出现的顺序执行</p><p><code>&lt;clinit&gt;()</code>不同于类的构造器，如果没有静态变量和静态代码块也不会有clinit方法</p><p>init方法是一定会有的，就是构造器方法</p><p>若该类具有父类，jvm会保证子类的clinit执行前，父类的clinit已经执行完毕</p><p>虚拟机必须保证一个类的clinit方法在多线程下被同步加锁</p><h2 id="（5）类加载器的分类"><a href="#（5）类加载器的分类" class="headerlink" title="（5）类加载器的分类"></a>（5）类加载器的分类</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2024/09/23/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/09/23/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h1><p>java中所有对象继承自object类，被称为单根层次结构（singly-rooted hierarchy）</p><p>有利于系统级别的操作，比如实现垃圾收集器</p><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h1><p>基本数据类型会直接在栈上存储值</p><h1 id="3-数据在哪里存储"><a href="#3-数据在哪里存储" class="headerlink" title="3.数据在哪里存储"></a>3.数据在哪里存储</h1><p><strong>寄存器</strong></p><p>速度最快，直接保存在CPU，但是寄存器数量有限，且无法直接控制</p><p><strong>栈</strong></p><p>存储在RAM中，处理器通过栈指针直接操作数据，向下移动申请内存，向上移动释放内存，效率仅次于寄存器。</p><p><strong>堆</strong></p><p>通用内存池，也在RAM空间，编译器不关心其中对象存活时间</p><p><strong>常量存储</strong></p><p>常量直接保存在代码里面，有的时候在嵌入式系统里面会放在ROM中</p><p><strong>非RAM存储</strong></p><p>序列化对象：转化为字节流并可以发送到其他机器</p><p>持久化对象：存储在磁盘上，需要时可以转化为RAM对象</p><h1 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h1><p>数组成员默认初始化，局部变量不会初始化</p><h1 id="5-Integer"><a href="#5-Integer" class="headerlink" title="5.Integer"></a>5.Integer</h1><p>缓存-128-127，创建对象时尽量使用 Integer.valueof()</p><h1 id="6-移位运算符"><a href="#6-移位运算符" class="headerlink" title="6.移位运算符"></a>6.移位运算符</h1><p>对char，byte，short数值进行移位运算，移位前会被转换为int，结果也是int</p><h1 id="7-构造器"><a href="#7-构造器" class="headerlink" title="7.构造器"></a>7.构造器</h1><p>在构造器中可以调用其他构造器方法，但是只能调用一个，且必须在最开始调用</p><p>非构造器方法不可以调用构造器方法</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/23/javaweb/"/>
      <url>/2024/09/23/javaweb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="一、Tomcat"><a href="#一、Tomcat" class="headerlink" title="一、Tomcat"></a>一、Tomcat</h2><h3 id="1-XML解析"><a href="#1-XML解析" class="headerlink" title="1.XML解析"></a>1.XML解析</h3><h4 id="jdbc-xml"><a href="#jdbc-xml" class="headerlink" title="jdbc.xml"></a>jdbc.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dev</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">            123456</span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dev</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ser</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">            38413</span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ser</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbc</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="xmlresolve-java"><a href="#xmlresolve-java" class="headerlink" title="xmlresolve.java"></a>xmlresolve.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlResolve</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException &#123;</span><br><span class="line">        <span class="comment">// 读取jdbc.xml, 获得document对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 通过类加载器获得指向字节码根路径下的指定文件的输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> XmlResolve.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.xml&quot;</span>);</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(inputStream);</span><br><span class="line">        <span class="comment">// 读取documnet</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        node 节点</span></span><br><span class="line"><span class="comment">        element 元素节点</span></span><br><span class="line"><span class="comment">        attribute 属性节点</span></span><br><span class="line"><span class="comment">        text 文本节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(<span class="string">&quot;root: &quot;</span>+rootElement.getName());</span><br><span class="line">        <span class="comment">//获取子元素并且读取</span></span><br><span class="line">        List&lt;Element&gt; elements = rootElement.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\t&quot;</span>+element.getName());</span><br><span class="line">            <span class="type">Attribute</span> <span class="variable">attribute</span> <span class="operator">=</span> element.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t&quot;</span>+attribute.getValue());</span><br><span class="line">            <span class="keyword">for</span> (Element element1 : element.elements()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;\t\t&quot;</span>+element1.getName()+<span class="string">&quot;: &quot;</span>+element1.getText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root: jdbc</span><br><span class="line">dev</span><br><span class="line">1</span><br><span class="line">url: </span><br><span class="line">            123456</span><br><span class="line">        </span><br><span class="line">ser</span><br><span class="line">2</span><br><span class="line">url: </span><br><span class="line">            38413</span><br></pre></td></tr></table></figure><h3 id="2-tomcat10"><a href="#2-tomcat10" class="headerlink" title="2.tomcat10"></a>2.tomcat10</h3><p>tomcat是服务器软件</p><p>看完了好像没啥东西</p><h2 id="二、HTTP协议"><a href="#二、HTTP协议" class="headerlink" title="二、HTTP协议"></a>二、HTTP协议</h2><p>再说吧</p><h2 id="三、Servlet"><a href="#三、Servlet" class="headerlink" title="三、Servlet"></a>三、Servlet</h2><p>server applet 是运行在服务端上的java程序，用来接收来自客户端的请求，动态生成数据。</p><p>servlet是一套规范，代码层面是接口。</p><p>servlet生成的是数据，打包成报文是tomcat完成的。</p><h3 id="1-执行过程"><a href="#1-执行过程" class="headerlink" title="1.执行过程"></a>1.执行过程</h3><p>tomcat收到客户端的请求报文后会将请求报文的信息转换为一个HttpServletRequest对象，该对象包含请求行，请求头，请求体</p><p>tomcat同时创建了一个HttpServletResponse用来存放响应给客户端的信息，该对象会被转换为响应报文</p><p>实现了servlet接口的类需要指定url和实现一个service方法</p><p>该方法参数为HttpServletRequest，HttpServletResponse</p><p>tomcat通过请求头中的url找到对应的servlet并将它实例化</p><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240322142912191.png" alt="image-20240322142912191"></p><h3 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">yes</span> <span class="operator">=</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(username == <span class="string">&quot;ssx&quot;</span>)&#123;</span><br><span class="line">            info = yes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        <span class="built_in">super</span>.service(req, resp);</span><br><span class="line">        printWriter.write(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-路径指定"><a href="#3-路径指定" class="headerlink" title="3.路径指定"></a>3.路径指定</h3><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240322153649398.png" alt="image-20240322153649398"></p><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240322154046396.png" alt="image-20240322154046396"></p><h3 id="4-jar包导入问题"><a href="#4-jar包导入问题" class="headerlink" title="4.jar包导入问题"></a>4.jar包导入问题</h3><p>servlet-api这个包在tomcat中本身就有，所以应当作为provided(编码中生效)来引入</p><h3 id="5-contentType"><a href="#5-contentType" class="headerlink" title="5.contentType"></a>5.contentType</h3><p>MIME类型响应头 客户端依此决定如何解析响应体</p><p>默认是html</p><p>如果请求的是静态资源，tomcat会依据后缀来确定类型（.html .png …）</p><p>在tomcat的conf&#x2F;web.xml中存放了类型和mime类型的对应关系，形式为mimemapping标签</p><p>如果是动态资源，servlet类应当设置contenttype</p><h3 id="6-注解配置servlet"><a href="#6-注解配置servlet" class="headerlink" title="6.注解配置servlet"></a>6.注解配置servlet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/aaa&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span></span><br></pre></td></tr></table></figure><p>不要注解配置后也在xml中配置会报错</p><h3 id="7-生命周期"><a href="#7-生命周期" class="headerlink" title="7.生命周期"></a>7.生命周期</h3><ol><li><p>实例化                                第一次请求&#x2F;服务启动 取决于loadonstart</p></li><li><p>初始化                                构造完毕  执行init函数（无参数版本）</p></li><li><p>服务（接受并处理请求） 每次请求</p></li><li><p>销毁                                    关闭请求</p></li></ol><p>servlet默认单例，所以尽量不要有成员变量会有线程不安全问题</p><p>web.xml中可以设置load-on-start属性 -1就是tomcat启动时不实例化servlet</p><p>正值表示启动时的实例化顺序（数字越大越靠后）但是不建议为1，因为conf&#x2F;web.xml有一个default-servlet</p><p>当tomcat无法匹配到请求报文中的servlet就会转发给default-servlet</p><p>也就是说，静态资源都是default-servlet处理的</p><h3 id="8-servlet继承"><a href="#8-servlet继承" class="headerlink" title="8.servlet继承"></a>8.servlet继承</h3><p>httpservlet extends genericServlet </p><p>GenericServlet implements Servlet, ServletConfig, Serializable</p><h4 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h4><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240322190543238.png" alt="image-20240322190543238"></p><p>GenericServlet是一个抽象类，将接口中的destroy实现为普通方法，是一个空方法称为平庸实现，由此此类可以不重写该方法</p><p>同时实现了init方法，会读取配置信息servletconfig并且装入init方法来实现config的存储，而调用另一个无参init方法，该无参init有子类实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.config = config;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对service方法实现为抽象方法，子类必须实现</p><h4 id="httpservlet"><a href="#httpservlet" class="headerlink" title="httpservlet"></a>httpservlet</h4><p>抽象类  侧重service方法的处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="keyword">instanceof</span> HttpServletResponse) &#123;</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest)req;</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse)res;</span><br><span class="line">            <span class="built_in">this</span>.service(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接口父转子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="type">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据不同请求方式调用doOption函数，例如doDelete就是提示notallowed并且把msg写入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDelete</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> req.getProtocol();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_delete_not_supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (protocol.endsWith(<span class="string">&quot;1.1&quot;</span>)) &#123;</span><br><span class="line">            resp.sendError(<span class="number">405</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.sendError(<span class="number">400</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是说如果没重写就提示不可用</p><p>同时也可以重写doxxx方法来代替重写service方法，因为httpservlet的service方法做了一些处理</p><h3 id="9-配置参数"><a href="#9-配置参数" class="headerlink" title="9.配置参数"></a>9.配置参数</h3><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20240322201328269.png" alt="image-20240322201328269"></p><p>init-param和context-param会被转化为servletConfig和servletContext</p><p>可以用xml配置也可以用注解配置</p><p>servletConfig是每个servlet一个</p><p>servletContext是单例的</p><h3 id="10-servletContext-api"><a href="#10-servletContext-api" class="headerlink" title="10.servletContext-api"></a>10.servletContext-api</h3><p>servletContext.getRealPath(“upload”)  当前目录下一个叫upload资源的地址</p><p>servletContext.getContextPath() 项目上下文路径，可以</p><h3 id="11-域对象"><a href="#11-域对象" class="headerlink" title="11.域对象"></a>11.域对象</h3><p>即在不同域范围内存储数据和传输数据的对象</p><p>例如servletContext代表应用域，是最大的域，可以在本应用内传递数据</p><p><strong>API</strong></p><p>servletContext.setAttribute(“key”,object)</p><p>servletContext.getAttribute(“key”)</p><p><strong>三大域</strong></p><p>应用域，会话域，请求域</p><h3 id="12-httpServletRequest、httpServletResponse"><a href="#12-httpServletRequest、httpServletResponse" class="headerlink" title="12.httpServletRequest、httpServletResponse"></a>12.httpServletRequest、httpServletResponse</h3><h4 id="获取请求行的相关信息"><a href="#获取请求行的相关信息" class="headerlink" title="获取请求行的相关信息"></a>获取请求行的相关信息</h4><p>getMethod：返回HTTP请求消息中的请求方式</p><p>getRequestURI：返回请求行中的资源名部分</p><p>getSchema: 返回请求协议</p><p><strong>具体api都差不多都是set和get方法</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git学习和使用</title>
      <link href="/2024/09/23/git%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/09/23/git%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1. 版本控制"></a>1. 版本控制</h1><h2 id="集中式版本控制"><a href="#集中式版本控制" class="headerlink" title="集中式版本控制"></a>集中式版本控制</h2><h3 id="VSS"><a href="#VSS" class="headerlink" title="VSS"></a>VSS</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230418133740396.png" alt="image-20230418133740396"></p><p>文件冲突：一个用户下载后会对资源加锁，别的用户只读不可写，在上传后会解锁。</p><h3 id="CVS-SVN"><a href="#CVS-SVN" class="headerlink" title="CVS SVN"></a>CVS SVN</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230418133721840.png" alt="image-20230418133721840"></p><p>同文件不同行可以协作，同一行同样会冲突</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>中央服务器出错，所有用户无法协作</p><h2 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h2><p>本地存储中央服务器的副本</p><h1 id="2-版本号"><a href="#2-版本号" class="headerlink" title="2. 版本号"></a>2. 版本号</h1><p>四十位十六进制字符串，使用SHA-1算法生成</p><p>首先可以避免版本冲突，因为版本都是对应于自己的仓库</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419150020639.png" alt="image-20230419150020639"></p><p>版本号同时还可以用于定位文件(2+38)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cat-file -p 版本号</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419150257308.png" alt="image-20230419150257308"></p><p>100普通文件 644文件权限</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419151052059.png" alt="image-20230419151052059"></p><p>每一个版本号对应的文件成树状结构</p><p>commit的版本号会有一个parent指向上一个提交</p><p>不同提交中未变更的内容会被文件状态的版本号指向同一个版本号</p><p>若删除文件只是删除了文件状态版本号内容中对删除的文件内容的版本号的指向</p><h1 id="3-HEAD"><a href="#3-HEAD" class="headerlink" title="3. HEAD"></a>3. HEAD</h1><p><code>.git</code>文件中有一个HEAD文件，HEAD用来指向分支</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419151618908.png" alt="image-20230419151618908"></p><p>HEAD指向分支，而分支指向不同的commit，commit指向文件状态，文件状态持有对不同文件的指向，从而实现了版本控制。</p><h1 id="4-git-指令"><a href="#4-git-指令" class="headerlink" title="4. git 指令"></a>4. git 指令</h1><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419152353708.png" alt="image-20230419152353708"></p><h2 id="1-仓库操作"><a href="#1-仓库操作" class="headerlink" title="(1) 仓库操作"></a>(1) 仓库操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br></pre></td></tr></table></figure><p>初始化仓库，初始化的仓库中没有master，因为没有commit过</p><p>objects中也是空的，么有内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> url [<span class="built_in">local</span> name]</span></span><br></pre></td></tr></table></figure><p>clone仓库到本地,local name可选</p><p>将远程仓库的所有commit都下载下来</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config [配置项] [value] [--global]</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config user.name xxx</span><br><span class="line">git config user.emial xxx</span><br></pre></td></tr></table></figure><p><strong>不要加引号</strong></p><h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="(2) 文件操作"></a>(2) 文件操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br></pre></td></tr></table></figure><p>查询暂存区状态</p><p>如果有文件未add会报告为untracked</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add filename</span></span><br></pre></td></tr></table></figure><p>将文件放入暂存区，会自动比对，同样的文件会自动忽略</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> filename</span></span><br></pre></td></tr></table></figure><p>将文件移除暂存区</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m<span class="string">&quot;message&quot;</span></span></span><br></pre></td></tr></table></figure><p>提交到存储区</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> [--oneline]</span></span><br></pre></td></tr></table></figure><p>查看commit history</p><p>oneline会缩写版本号</p><h2 id="3-误删除怎么办"><a href="#3-误删除怎么办" class="headerlink" title="(3) 误删除怎么办"></a>(3) 误删除怎么办</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git restore filename</span></span><br></pre></td></tr></table></figure><p>如果将变更已经commit则无法restore</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard 版本号</span></span><br></pre></td></tr></table></figure><p>可能会丢失后续的提交</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git revert 版本号</span></span><br></pre></td></tr></table></figure><p>实际上是将该版本再次commit</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419185919135.png" alt="image-20230419185919135"></p><h2 id="4-分支操作"><a href="#4-分支操作" class="headerlink" title="(4) 分支操作"></a>(4) 分支操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch branchname</span></span><br></pre></td></tr></table></figure><p>生成分支</p><p>branch是要基于commit的，没有commit的仓库无法生成分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout branchname</span></span><br></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b branchname</span></span><br></pre></td></tr></table></figure><p>创建并切换分支</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d branchname</span></span><br></pre></td></tr></table></figure><p>删除分支</p><h2 id="5-合并分支"><a href="#5-合并分支" class="headerlink" title="(5) 合并分支"></a>(5) 合并分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge branchname</span></span><br></pre></td></tr></table></figure><p>将该分支合并到本分支</p><p>有冲突会在文件中显示，此时为merge状态，在解决冲突后再次commit即可完成merge</p><h2 id="6-tag"><a href="#6-tag" class="headerlink" title="(6) tag"></a>(6) tag</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag tagcontent 版本号</span></span><br></pre></td></tr></table></figure><p>-d即可删除</p><h2 id="7-远程仓库"><a href="#7-远程仓库" class="headerlink" title="(7) 远程仓库"></a>(7) 远程仓库</h2><p>.git 中 config 文件中 remote下存放远程的url</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin url</span></span><br></pre></td></tr></table></figure><p>设置远程仓库url</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase branchname</span></span><br></pre></td></tr></table></figure><p>寻找本分支和branchname这个分支的同一个先祖commit，然后以branchname这个分支的最新commit依次合并本分支的所有提交</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419194404589.png" alt="image-20230419194404589"></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+picgo图床构建</title>
      <link href="/2024/09/23/github+picgo%E5%9B%BE%E5%BA%8A%E6%9E%84%E5%BB%BA/"/>
      <url>/2024/09/23/github+picgo%E5%9B%BE%E5%BA%8A%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="正式介绍之前，先解释一下，什么是图床？"><a href="#正式介绍之前，先解释一下，什么是图床？" class="headerlink" title="正式介绍之前，先解释一下，什么是图床？"></a>正式介绍之前，先解释一下，什么是图床？</h1><p>顾名思义，图床就是图片睡觉的地方。哈哈哈，开个玩笑，实际上图床是指存储图片的服务器。</p><h1 id="为什么要使用图床呢？"><a href="#为什么要使用图床呢？" class="headerlink" title="为什么要使用图床呢？"></a>为什么要使用图床呢？</h1><p>因为图片也需要睡觉呀。【掩嘴笑~】。</p><p>实际上使用图床是为了方便图片的统一处理。想象一下，当你写完一篇文章，而且文章有许多图片，这些图片都存储在电脑的硬盘上。</p><p>这时候想要把文章上传到公众号，或者是博客平台，那么不仅仅需要复制文字，还要在平台编辑器里一张一张地选择图片进行上传。</p><p>这样一来，不仅仅要耗费大量的时间传图片，还需要上传后检查图片顺序是否正确。整个过程相当繁琐，特别地消耗精力。</p><p>如果还需要同步到多个平台进行发布更是让人头大。</p><p>并且存储在服务器上，也不会存在电脑硬盘损坏，导致图片丢失的问题。</p><p>来做一个简单的算法(算术题)，一篇文章10张图片，需要上传至5个平台，那么总计需要上传50次。</p><p>我曾经的一片讲解算法的文章，有20多张图片，当我把图片完全上传到博客之后，脑子里只有一个想法：我一定要搭建一个图床，我再也不想传第二遍了。</p><p>但是最后，我还是一张一张的把图片上传到了公众号后台，因为图床还没来得及搭建。</p><p>当我把图床做好后，图片上传的问题就简单了，只需要将文章复制、粘贴即可。在写文章时将编辑器和图床联合在一起使用，放置图片的地方就全都变成了图片的链接地址。</p><p>效果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419130540850.png" alt="image-20230419130540850"></p><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="NO-1-配置github"><a href="#NO-1-配置github" class="headerlink" title="NO.1 配置github"></a>NO.1 配置github</h2><p>首先你需要一个github账号，如果没有的话，先注册。github官网地址 github.com</p><p>注册过程省略，因为这是保姆都不管的事情。</p><p>友情提示：可能在注册过程中会出现 “Unable to verify your captcha response… …”，一直不能正常注册。</p><p>网上有各种解决方案：换浏览器、换电脑… …</p><p>笔者初次注册时，是在家用自己的笔记本和谷歌浏览器，注册一直不成功。次日用工作电脑+谷歌浏览器，注册成功。</p><h3 id="1-创建一个新仓库，用于存放图片。"><a href="#1-创建一个新仓库，用于存放图片。" class="headerlink" title="1.创建一个新仓库，用于存放图片。"></a>1.创建一个新仓库，用于存放图片。</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419130621547.png" alt="image-20230419130621547"></p><p>填写仓库名称和描述，且仓库必须是public的，否则存储的图片不能正常访问。</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419130643936.png" alt="image-20230419130643936"></p><h3 id="2-生成一个token，用于picGo访问github"><a href="#2-生成一个token，用于picGo访问github" class="headerlink" title="2.生成一个token，用于picGo访问github"></a>2.生成一个token，用于picGo访问github</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419130948071.png" alt="image-20230419130948071"></p><p>选择左侧菜单的Developer settings</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419131040590.png" alt="image-20230419131040590"></p><p>之后选择左侧Personal access tokens，再点击Generate new token</p><p>填写Note，勾选repo.</p><p>注意，生成的token只会在这里显示一次，所以记得单独保存下来哦。</p><p>至此，Github的配置完成。</p><h2 id="NO-2-下载picGo，并进行配置"><a href="#NO-2-下载picGo，并进行配置" class="headerlink" title="NO.2 下载picGo，并进行配置"></a>NO.2 下载picGo，并进行配置</h2><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h3><p>访问picGo下载地址，选择 picGo-Setup-XXX.exe下载软件安装包即可。</p><p>下载完成，双击启动安装即可。</p><p>如果安装成功，picGo不能正常使用，则可以用兼容模式启动。【此问题因电脑而异，也是我在配置过程中踩过的坑。】</p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419131059313.png" alt="image-20230419131059313"></p><p>仓库名：[github用户名]&#x2F;[第一步新建的仓库名称]</p><p>分支：默认master，从2020.10.01开始，github的默认分支名变更为main</p><p>设定token：第一步创建的token</p><p>指定存储路径：可填可不填，如果填写了，图片就会存储在img文件夹下</p><p>设定自定义域名：<a href="https://cdn.jsdelivr.net/gh/github%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/github用户名/仓库名</a></p><p>至此，github+picGo的配置完成，可以在上传区进行图片上传了。</p><h2 id="NO-3-Typora"><a href="#NO-3-Typora" class="headerlink" title="NO.3 Typora"></a>NO.3 Typora</h2><h3 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1.下载安装"></a>1.下载安装</h3><p>可点击typora下载地址进行下载</p><h3 id="2-配置-1"><a href="#2-配置-1" class="headerlink" title="2.配置"></a>2.配置</h3><p>在typora顶部菜单界面，选择“文件” - &gt; “偏好设置”，设置图片存储方式。</p><p>选择图片存储方式：上传图片。</p><p>上传服务：PicGo(app)</p><p>PicGo路径：picGo安装的地址</p><p>设置完成，点击“验证图片上传”，提示上传成功，即代表配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230419131118561.png" alt="image-20230419131118561"></p><p>注意一点，typora图片验证中的端口，需要与picGo中的server设置内的端口一致，否则typora中不能正常上传。</p><p>picGo监听端口设置</p><p>选择“PicGo设置”–&gt;“设置server”</p><p><strong>【此处有坑】</strong>如果监听端口不是36677，则需要修改为36677。否则会出现picGo能正常上传 图片，而typora上传图片失败的情况。</p><p>最后，在苹果电脑中可以使用typora+Ipic+github的方式，有兴趣的话可以自行尝试。</p><p>总结：github+picGo+typora他们三个是好基友。</p><p>分享到此结束，保姆也该撤了~</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网笔记</title>
      <link href="/2024/09/23/%E7%89%A9%E8%81%94%E7%BD%91%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/23/%E7%89%A9%E8%81%94%E7%BD%91%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/09/23/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/09/23/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 图节点的逻辑结构 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"> <span class="type">int</span> id;</span><br><span class="line"> Vertex[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="comment">// graph[x] 存储 x 的所有邻居节点</span></span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="comment">// matrix[x][y] 记录 x 是否有⼀条指向 y 的边</span></span><br><span class="line"><span class="type">boolean</span>[][] matrix;</span><br></pre></td></tr></table></figure><h1 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/submissions/">所有可能的路径</a></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        traverse(graph,<span class="number">0</span>,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> s, LinkedList&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        path.addLast(s);</span><br><span class="line">        <span class="keyword">if</span>(s == graph.length-<span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> next : graph[s])&#123;</span><br><span class="line">            traverse(graph,next,path);</span><br><span class="line">        &#125;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点在于当你进入一个节点的时候你还要出去，这样path才会正确遍历所有的路径</p><h1 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">课程表</a></h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 建图，和环检测算法相同</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">        <span class="comment">// 计算入度，和环检测算法相同</span></span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">            indegree[to]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据入度初始化队列中的节点，和环检测算法相同</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录拓扑排序结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// 记录遍历节点的顺序（索引）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始执行 BFS 算法</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 弹出节点的顺序即为拓扑排序结果</span></span><br><span class="line">            res[count] = cur;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">                indegree[next]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count != numCourses) &#123;</span><br><span class="line">            <span class="comment">// 存在环，拓扑排序不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建图函数</span></span><br><span class="line">    List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 修完课程 from 才能修课程 to</span></span><br><span class="line">            <span class="comment">// 在图中添加一条从 from 指向 to 的有向边</span></span><br><span class="line">            graph[from].add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一个BFS的做法，相当于每一层都扫描好了才会扫描下一层，关键代码是：</p><p>假如存在一个环，那么这个环的开始节点的入度永远不会为0，因为他的一个父节点在他的子树里面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">                indegree[next]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>所以，最后没有出现在拓扑排序数组里面的就是成环的节点。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 添加⼀条从 from 指向 to 的有向边</span></span><br><span class="line">        <span class="comment">// 边的⽅向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录⼀次递归堆栈中的节点</span></span><br><span class="line"><span class="type">boolean</span>[] onPath;</span><br><span class="line"><span class="comment">// 记录遍历过的节点，防⽌⾛回头路</span></span><br><span class="line"><span class="type">boolean</span>[] visited;</span><br><span class="line"><span class="comment">// 记录图中是否有环</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">List&lt;Integer&gt;[] graph;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    graph = buildGraph(numCourses, prerequisites);</span><br><span class="line"></span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历图中的所有节点</span></span><br><span class="line">        traverse(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只要没有循环依赖可以完成所有课程</span></span><br><span class="line">    <span class="keyword">return</span> !hasCycle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 出现环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="comment">// 如果已经找到了环，也不⽤再遍历了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序代码位置</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : graph[s]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hasCycle) <span class="keyword">break</span>;</span><br><span class="line">        traverse( t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序代码位置</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1.设计原则"></a>1.设计原则</h1><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613150954992.png" alt="image-20230613150954992"></p><h2 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h2><p><em><strong>Open-Closed Principle, OCP</strong></em></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对扩展开放，对修改关闭。</p><p>使得程序的扩展性好，易于维护和升级</p><p><strong>抽象化是开闭原则的关键。</strong></p><p> • 开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则(Principle of Encapsulation of Variation, EVP)要求找到系统的可变 因素并将其封装起来。</p><p>Software entities should be open for extension, but closed for modification.</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613151230819.png" alt="image-20230613151230819"></p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613151244914.png" alt="image-20230613151244914"></p><h2 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2.单一职责原则"></a>2.单一职责原则</h2><p><em><strong>Single Responsibility Principle, SRP</strong></em></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一个对象应该只包含单一的职责，并且该职责被完整 地封装在一个类中。</p><p>Every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class.</p><p>就一个类而言，应该仅有一个引起它变化的原因。</p><p>There should never be more than one reason for a class to change.</p><p>一个类（或者大到模块，小到方法）承担的职责越多， 它被复用的可能性越小，而且如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。</p><p>类的职责主要包括两个方面：<strong>数据职责</strong>和<strong>行为职责</strong>，数据职责通过其属性来体现，而行为职责通过其方法来体现。</p><p>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，在很 多代码重构手法中都能找到它的存在，它是最简单但又 最难运用的原则，需要设计人员发现类的不同职责并将 其分离，而发现类的多重职责需要设计人员具有较强的 分析设计能力和相关重构经验。</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613151540380.png" alt="image-20230613151540380"></p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613151559287.png" alt="image-20230613151559287"></p><h2 id="3-里氏代换原则"><a href="#3-里氏代换原则" class="headerlink" title="3.里氏代换原则"></a>3.里氏代换原则</h2><p><em><strong>Liskov Substitution Principle, LSP</strong></em></p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象</p><p>• Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p><p>里氏代换原则可以通俗表述为：在软件中如果能够使用基 类对象，那么一定能够使用其子类对象。把基类都替换成 它的子类，程序将不会产生任何错误和异常，反过来则不 成立，如果一个软件实体使用的是一个子类的话，那么它 不一定能够使用基类。</p><p><strong>里氏代换原则是实现开闭原则的重要方式之一</strong>，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><ol><li>某系统需要实现对重要数据（如用户密码）的加密处理，在数据操作类(DataOperator)中需要调用加密类中定义的加密算法，系统提供了两个不同的加密类，CipherA和CipherB，它们实现不同的加密方法，在DataOperator中可以选择其中的一个实现加密操作。如图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613152028981.png" alt="image-20230613152028981"></p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613152134376.png" alt="image-20230613152134376"></p><h2 id="4-依赖倒转原则"><a href="#4-依赖倒转原则" class="headerlink" title="4.依赖倒转原则"></a>4.依赖倒转原则</h2><p><em><strong>Dependence Inversion Principle, DIP</strong></em></p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>• 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p>High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.</p><p>要针对接口编程，不要针对实现编程。</p><p>Program to an interface, not an implementation</p><ol><li><p>简单来说，依赖倒转原则就是指：<strong>代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程</strong>。</p></li><li><p>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说<strong>开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段</strong>。</p></li><li><p>依赖倒转原则的常用实现方式之一是</p><p>在代码中使用抽象类，而将具体类放在配置文件</p><ol><li><strong>将抽象放进代码，将细节放进元数据</strong></li><li><strong>Put Abstractions in Code, Details in Metadata</strong></li><li>《程序员修炼之道：从小工到专家》(The Pragmatic programmer: from journeyman to master)</li></ol></li><li><p>类之间的耦合</p><ol><li><strong>零耦合</strong>关系：最好情况</li><li><strong>具体耦合</strong>关系</li><li><strong>抽象耦合</strong>关系：依赖倒转要求至少一端是抽象的</li></ol></li><li><p>依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。</p></li><li><p>依赖注入</p><ol><li>构造注入(Constructor Injection)：通过<strong>构造函数</strong>注入实例变量。</li><li>设值注入(Setter Injection)：通过<strong>Setter方法</strong>注入实例变量</li><li>接口注入(Interface Injection)：通过<strong>接口方法</strong>注入实例变量。</li></ol></li></ol><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613153640355.png" alt="image-20230613153640355"></p><p>由于需求的变化，该系统可能需要增加新的数据源或者新的文件格式，每增加一个新的类型 的数据源或者新的类型的文件格式，客户类 MainClass都需要修改源代码，以便使用新的类 ，但违背了开闭原则。现使用依赖倒转原则对其进行重构。</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613153737677.png" alt="image-20230613153737677"></p><h2 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5.接口隔离原则"></a>5.接口隔离原则</h2><p><em><strong>Interface Segregation Principle, ISP</strong></em></p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>客户端不应该依赖那些它不需要的接口</p><p>Clients should not be forced to depend upon interfaces that they do not use. </p><p>注意，在该定义中的接口指的是所定义的方法。</p><p>一旦一个接口太大，则需要将它分割成一些更细小的接口， 使用该接口的客户端仅需知道与之相关的方法即可。</p><p>Once an interface has gotten too ‘fat’ it needs to be split into smaller and more specific interfaces so that any clients of the interface will only know about the methods that pertain to them. </p><ol><li><p>接口隔离原则是指</p><p>使用多个专门的接口，而不使用单一的总接口</p><p>。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。</p><ol><li>一个接口就<strong>只代表一个角色</strong>，每个角色都有它特定的一个接口，此时这个原则可以叫做”角色隔离原则”。</li><li>接口<strong>仅仅提供客户端需要的行为</strong>，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li></ol></li><li><p>使用接口隔离原则拆分接口时，首先必须满足<strong>单一职责原则</strong>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</p></li><li><p>可以在进行系统设计时采用<strong>定制服务</strong>的方式，即<strong>为不同的客户端提供宽窄不同的接口</strong>，只提供用户需要的行为，而隐藏用户不需要的行为。</p></li></ol><h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><ol><li>下图展示了一个拥有多个客户类的系统，在系统中定义了一个巨大的接口（胖接口）AbstractService来服务所有的客户类。可以使用接口隔离原则对其进行重构。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613154836717.png" alt="image-20230613154836717"></p><h2 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h2><p><em><strong>Composite Reuse Principle, CRP</strong></em></p><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>尽量使用对象组合，而不是继承来达到复用的 目的。</p><p>• Favor composition of objects over inheritance as a reuse mechanism.</p><p>合成复用原则就是指在一个新的对象里通过关联 关系（包括组合关系和聚合关系）来使用一些已 有的对象，使之成为新对象的一部分；新对象通 过委派调用已有对象的方法达到复用其已有功能 的目的。简言之：要尽量使用组合&#x2F;聚合关系，少 用继承。</p><p>在面向对象设计中，可以通过两种基本方法在不 同的环境中复用已有的设计和实现，即通过组合&#x2F; 聚合关系或通过继承。</p><p><strong>继承复用</strong>：实现简单，易于扩展。破坏系统的 封装性；从基类继承而来的实现是静态的，不 可能在运行时发生改变，没有足够的灵活性； 只能在有限的环境中使用。（“白箱”复用 ）</p><p><strong>组合&#x2F;聚合复用</strong>：耦合度相对较低，选择性地调 用成员对象的操作；可以在运行时动态进行。 （“黑箱”复用 ）</p><p>组合&#x2F;聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合&#x2F;聚合来实现复用 ；其次才考虑继承，在使用继承时，需要严格遵循<strong>里氏代换原则</strong>，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系 统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><h3 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h3><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613155159209.png" alt="image-20230613155159209"></p><p>如果需要更换数据库连接方式，如原来采用JDBC连接数据库，现在采用数据库连接池连接，则需要修改DBUtil类源代码。如果StudentDAO采用JDBC连接，但是TeacherDAO采用连接池连接，则需要增加一个新的DBUtil类，并修改StudentDAO或TeacherDAO的源代码，使之继承新的数据库连接类，这将违背开闭原则，系统扩展性较差。</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613155242326.png" alt="image-20230613155242326"></p><h2 id="7-迪米特法则"><a href="#7-迪米特法则" class="headerlink" title="7.迪米特法则"></a>7.迪米特法则</h2><p><em><strong>Law of Demeter, LoD</strong></em></p><p><em><strong>Least Knowledge Principle, LKP</strong></em></p><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>迪米特法则(Law of Demeter, LoD)又称为最少知识原则(Least Knowledge Principle, LKP)，它有多种定义方法，其中几种典型定义如下：</p><ol><li><strong>不要和”陌生人”说话</strong>。英文定义为：Don’t talk to strangers.</li><li><strong>只与你的直接朋友通信</strong>。英文定义为：Talk only to your immediate friends.</li><li><strong>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</strong>。英文定义为：Each unit should have only limited knowledge about other units: only units “closely” related to the current unit</li></ol><p>简单地说，迪米特法则就是指<strong>一个软件实体应当尽可能少的与其他实体发生相互作用</strong>。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。</p><p>在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><ol><li>当前对象本身(this)</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象。</li></ol><p><strong>狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用</strong></p><p>如果其中的一个类需要调用另一个类的某一个方法的话，可以通过<strong>第三者转发这个调用</strong>。下图中，只允许A调用B对象的方法，但是不能调用C对象的方法(但是我们可以通过在B中添加一个Wrapper方法来间接调用C)</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613155506427.png" alt="image-20230613155506427"></p><ol><li>狭义的迪米特法则：可以<strong>降低类之间的耦合</strong>，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会<strong>造成系统的不同模块之间的通信效率降低</strong>，使得系统的不同模块之间不容易协调。</li><li>广义的迪米特法则：指<strong>对对象之间的信息流量、流向以及信息的影响的控制</strong>，主要是<strong>对信息隐藏的控制</strong>。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。</li><li>迪米特法则的主要用途在于控制信息的过载：<ol><li>在类的划分上，应当尽量<strong>创建松耦合的类</strong>，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及</li><li>在类的结构设计上，每一个类都应当<strong>尽量降低其成员变量和成员函数的访问权限</strong></li><li>在类的设计上，只要有可能，<strong>一个类型应当设计成不变类</strong></li><li>在对其他类的引用上，<strong>一个对象对其他对象的引用应当降到最低</strong></li></ol></li></ol><h3 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h3><ol><li><p>某系统界面类(如Form1、Form2等类)与数据访问类(如DAO1、DAO2等类)之间的调用关系较为复杂，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613161130463.png" alt="image-20230613161130463"></p></li></ol><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613155650423.png" alt="image-20230613155650423"></p><h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2.设计模式"></a>2.设计模式</h1><p>设计模式分类</p><ol><li>模式本身<ol><li>创建型</li><li>结构型</li><li>行为型</li></ol></li><li>模式实现<ol><li>类模式：以集成为主要方式实现</li><li>对象模式：以合成为主要方式实现</li></ol></li></ol><h2 id="1-策略模式"><a href="#1-策略模式" class="headerlink" title="1.策略模式"></a>1.策略模式</h2><p>strategy pattern</p><h3 id="模式动机-将文本流分成几行"><a href="#模式动机-将文本流分成几行" class="headerlink" title="模式动机-将文本流分成几行"></a>模式动机-将文本流分成几行</h3><ol><li>存在许多用于将文本流分成行的算法。将所有这样的算法硬连接到类中是不可取的。</li><li>不满足开闭原则，每次修改都要反复检查每一个条件语句</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(String type)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(type.equals(<span class="string">&quot;strategyA&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;strategyB&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;strategyC&quot;</span>)) &#123;</span><br><span class="line">         <span class="built_in">this</span>.strategy = <span class="keyword">new</span> <span class="title class_">ConcreteStrategyC</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>在以下情况下使用策略模式<ol><li>许多相关的类仅在<strong>行为</strong>上有所不同，策略提供了一种使用多种行为之一配置类的方法</li><li>您需要<strong>算法的不同变体</strong>。例如，您可能定义了反映不同空间&#x2F;时间权衡的算法。将这些变体实现为算法的类层次结构时，可以使用策略。</li><li>一种算法使用客户端不应该知道的数据。使用策略模式<strong>可避免暴露复杂的、特定于算法的数据结构</strong></li><li>一个类定义了许多行为，这些行为在其操作中显示为多个条件语句。代替许多条件，将相关的条件分支移到他们自己的<strong>策略类</strong>中。</li></ol></li><li>很多问题都出现于数据结构被暴露：比如<strong>迭代器模式</strong>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613193120135.png" alt="image-20230613193120135"></p><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h2><p>factory pattern</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式(Simple Factory Pattern)：又称 为静态工厂方法(Static Factory Method)模式， 它属于类创建型模式。在简单工厂模式中，可以 根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被 创建的实例通常都具有共同的父类。</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230613193327320.png" alt="image-20230613193327320"></p><p>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。 </p><p>• 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何 Java源代码。</p><p> • 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新 的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</p><p> • 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细 节。</p><h4 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h4><h5 id="简单工厂模式的优点"><a href="#简单工厂模式的优点" class="headerlink" title="简单工厂模式的优点"></a>简单工厂模式的优点</h5><ol><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅”消费”产品；简单工厂模式通过这种做法<strong>实现了对责任的分割，它提供了专门的工厂类用于创建对象</strong>。</li><li><strong>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可</strong>，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li><strong>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类</strong>，在一定程度上提高了系统的灵活性。</li></ol><h5 id="简单工厂模式的缺点"><a href="#简单工厂模式的缺点" class="headerlink" title="简单工厂模式的缺点"></a>简单工厂模式的缺点</h5><ol><li>由于<strong>工厂类集中了所有产品创建逻辑</strong>，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会<strong>增加系统中类的个数</strong>，在一定程序上增加了系统的复杂度和理解难度。</li><li><strong>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时</strong>，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。只是把分散在系统各个地方的变化汇总到了一起。</li><li>简单工厂模式由于使用了静态工厂方法，造成<strong>工厂角色无法形成基于继承的等级结构</strong>。</li></ol><h4 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h4><ol><li><strong>工厂类负责创建的对象比较少</strong>：由于创建的对象较少，不会造成工厂方法中的业务逻辑<strong>太过复杂</strong>(如果扩展使比较少的)</li><li><strong>客户端只知道传入工厂类的参数，对于如何创建对象不关心</strong>：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数(比如只知道名称参数)</li></ol><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模 式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对 象，这样做的目的是将产品类的实例化操作延迟到工厂 子类中完成，即通过工厂子类来确定究竟应该实例化哪 一个具体产品类。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写一篇博文</title>
      <link href="/2024/09/23/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"/>
      <url>/2024/09/23/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>md最前方以<code>---</code> 包裹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">abcjs:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2024/09/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2024/09/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[i])&#123;</span><br><span class="line">                <span class="comment">// 交换</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即将i从0开始遍历，选择i到n之间最小的数放到i上</p><p>时间复杂度<em>O</em>(N^2)</p><p>空间复杂度为O(1)</p><h1 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h1><h2 id="1-普通插入排序"><a href="#1-普通插入排序" class="headerlink" title="(1)普通插入排序"></a>(1)普通插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;=<span class="number">0</span> ; j--) &#123;</span><br><span class="line">            <span class="comment">// 0~n 时,如果arr[n-1]&gt;arr[n],则交换</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                arr[j] = arr[j] ^ arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j] ^ arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] ^ arr[j+<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历数组，假设当前到达第 K 个元素，此时前面 0~K-1 个元素是已经排好序的，因此只需要比较第 K 个元素和第 K-1 个元素，如果前者比后者小，则交换两个元素，继续向前遍历，直到找到前者比后者大的数。</p><p>时间复杂度是O ( N ) ，但平均和最坏情况下仍然是O(N^2)<br>它的空间复杂度同样为O (1)。</p><h2 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="(2)希尔排序"></a>(2)希尔排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;      <span class="comment">//不断缩小gap，直到1为止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; (j+gap) &lt; arr.length; j++)&#123;     <span class="comment">//使用当前gap进行组内插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; (k+gap)&lt; arr.length; k += gap)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[k] &gt; arr[k+gap]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[k+gap];      <span class="comment">//交换操作</span></span><br><span class="line">                    arr[k+gap] = arr[k];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Sorting:  &quot;</span> + Arrays.toString(arr));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gap需要小于N，而获取gap序列在上述代码只是使用了等比数列，最好的可以将时间复杂度降到O(N^4&#x2F;3)</p><p>按照gap对数组进行分组，然后每组进行直接插入排序</p><h1 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 输入数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> L 左指针</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R 右指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> L,<span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求出中点(其实就是(L+R)/2,先减后加防止溢出)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对左侧排序</span></span><br><span class="line">    process(arr,L,mid);</span><br><span class="line">    <span class="comment">// 对右侧排序</span></span><br><span class="line">    process(arr,mid+<span class="number">1</span>,R);</span><br><span class="line">    <span class="comment">// 合并两边的子数组</span></span><br><span class="line">    merge(arr,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> L,<span class="type">int</span> M,<span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="comment">// 临时数组,用来存储排好序的一段数组元素,最后会拷贝回原数组</span></span><br><span class="line">    <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 临时数组的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左侧指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line">    <span class="comment">// 右侧指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> M+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 左右两个指针所指元素进行比较,小的元素存入temp,它的指针向后移动</span></span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=M &amp;&amp; p2&lt;=R)&#123;</span><br><span class="line">        temp[i++] = arr[p1]&gt;arr[p2] ? arr[p2++]:arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当其中一个指针已经走完,说明另一半数组剩余的元素都比当前元素大</span></span><br><span class="line">    <span class="comment">// 所以将剩余的元素直接拷贝到临时数组</span></span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=M)&#123;</span><br><span class="line">        temp[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;=R)&#123;</span><br><span class="line">        temp[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后再将临时数组拷贝回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; temp.length; j++) &#123;</span><br><span class="line">        arr[L+j] = temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过递归先分解，然后一层层合并</p><h1 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h1><p>快速排序其实是冒泡排序的一种改进，冒泡排序每次对相邻的两个数进行比较，这显然是一种比较浪费时间的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> high;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];   <span class="comment">//挖坑1：保存基准的值</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = temp;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Sorting: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    quickSort(arr, low, left-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, left+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是递归版的快速排序：通过把基准temp插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为递归的本质是栈，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSortByStack</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态的左右指针入栈</span></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    stack.push(arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> stack.pop();     <span class="comment">//出栈进行划分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIdx</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存中间变量</span></span><br><span class="line">        <span class="keyword">if</span>(pivotIdx &gt; low) &#123;</span><br><span class="line">            stack.push(low);</span><br><span class="line">            stack.push(pivotIdx - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pivotIdx &lt; high &amp;&amp; pivotIdx &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            stack.push(pivotIdx + <span class="number">1</span>);</span><br><span class="line">            stack.push(high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> high;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[l];    <span class="comment">//挖坑1：保存基准的值</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[r] &gt;= pivot)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; arr[l] &lt;= pivot)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = pivot;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/23/%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/09/23/%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100计划</title>
      <link href="/2024/09/23/%E5%8A%9B%E6%89%A3hot100%E8%AE%A1%E5%88%92/"/>
      <url>/2024/09/23/%E5%8A%9B%E6%89%A3hot100%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p> 已经做过的可能就不写了，太简单的也没必要写</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/">缺失的第一个正数</a></h2><blockquote><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p></blockquote><p>这题使用的是原地置换，遍历数组中的每一个元素，对于第i个元素，num[i] &#x3D; j, 则将 num[i] 和 j-1的元素互换，这样只要遍历数组找到不连续的项就可以了。</p><p>注意点：</p><p>1.遍历时对于每一个元素要一直置换，因为当你把另一个元素置换过来之后，该元素也可能不在正确的位置</p><p>2.判定是否置换的条件：一定要使用<code>nums[nums[i] - 1] != nums[i]</code></p><p>因为数组里面可能有重复元素，下标不一样也可能相同，比如[1,1]就会出现死循环。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                swap(nums,nums[i]-<span class="number">1</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a></h2><blockquote><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p></blockquote><p>虽然是简单题但是很有意思</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="literal">null</span>) &#123;</span><br><span class="line">                p1 = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p1=p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="literal">null</span>) &#123;</span><br><span class="line">                p2 = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>本质就是将两个链表接起来</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230515134210969.png" alt="image-20230515134210969"></p><p>一看就懂，这里要注意的是如果没有公共节点那么应该返回null是怎么做到的</p><p>关键在于要让指针p1,p2经历null，本来我是直接判断next的，但是实际上当他们同时null的时候就已经没有公共节点了</p><h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></h2><p>主要是快慢指针的用法，慢指针一次一步，快指针一次两步，但是怎么判断走到头了？奇偶不一样，可以很巧妙的处理</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230515142033367.png" alt="image-20230515142033367"></p><p>fast本身或者next为null就说明到头了，然后反转链表一一对应就好了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ListNode slow, fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="literal">null</span>)</span><br><span class="line">            slow = slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> reverse(slow);</span><br><span class="line">        <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left.val != right.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left = left.next;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网重新学习</title>
      <link href="/2024/09/23/%E8%AE%A1%E7%BD%91%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/09/23/%E8%AE%A1%E7%BD%91%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序相关算法</title>
      <link href="/2024/09/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
      <url>/2024/09/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="计算右侧⼩于当前元素的个数-315-计算右侧小于当前元素的个数-力扣（LeetCode）"><a href="#计算右侧⼩于当前元素的个数-315-计算右侧小于当前元素的个数-力扣（LeetCode）" class="headerlink" title="[计算右侧⼩于当前元素的个数](315. 计算右侧小于当前元素的个数 - 力扣（LeetCode）)"></a>[计算右侧⼩于当前元素的个数](<a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数 - 力扣（LeetCode）</a>)</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2024/09/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2024/09/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>BST的特点：中序遍历是有序的且为升序</p><p>如果输⼊⼀棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"> traverse(root.left);</span><br><span class="line"> <span class="comment">// 中序遍历代码位置</span></span><br><span class="line"> print(root.val);</span><br><span class="line"> traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="⼆叉搜索树中第-K-⼩的元素"><a href="#⼆叉搜索树中第-K-⼩的元素" class="headerlink" title="⼆叉搜索树中第 K ⼩的元素"></a><em><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst">⼆叉搜索树中第 K ⼩的元素</a></em></h1><p>我的思路：用三个变量记录当前遍历的元素，需要到达的元素和结果；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> stop=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       stop = k;</span><br><span class="line">       traverse(root);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">       traverse(root.left);</span><br><span class="line">       cnt++;</span><br><span class="line">       <span class="keyword">if</span>(stop == cnt) res = root.val;</span><br><span class="line">       traverse(root.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然而这样是O(N),浪费了BST的性质，如果每一个节点可以存储他的位置，那么就可以二分法查找了。</p><p>可以在每个节点中存储一个<code>size</code>字段，该字段表示该节点的子树共有多少节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"> <span class="type">int</span> val;</span><br><span class="line"> <span class="comment">// 以该节点为根的树的节点总数</span></span><br><span class="line"> <span class="type">int</span> size;</span><br><span class="line"> TreeNode left;</span><br><span class="line"> TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a><em><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a></em></h1><p>在中序遍历时只需要先遍历右子树就可以降序遍历，这样可以依次计算出和赋给节点值。维护一个sum变量即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span> ) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       convertBST(root.right);</span><br><span class="line">       sum+=root.val;</span><br><span class="line">       root.val = sum;</span><br><span class="line">       convertBST(root.left);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="验证⼆叉搜索树"><a href="#验证⼆叉搜索树" class="headerlink" title="验证⼆叉搜索树"></a><em><a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证⼆叉搜索树</a></em></h1><p>不能只检查左子树和右子树的根节点因为左子树的根节点的右节点可能比本节点大</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 限定以 root 为根的⼦树节点必须满⾜ max.val &gt; root.val &gt; min.val */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line"> <span class="comment">// base case</span></span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line"> <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">// 限定左⼦树的最⼤值是 root.val，右⼦树的最⼩值是 root.val</span></span><br><span class="line"> <span class="keyword">return</span> isValidBST(root.left, min, root)</span><br><span class="line"> &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我的思路是用INT的max和min直接传入min和max，但是会有超过int的数，使用long空间太大，还是用null代指最值吧。</strong></p><h1 id="BST的增删查"><a href="#BST的增删查" class="headerlink" title="BST的增删查"></a><em><strong>BST的增删查</strong></em></h1><p>搜索：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 去左⼦树搜索</span></span><br><span class="line"> <span class="keyword">if</span> (root.val &gt; target) &#123;</span><br><span class="line"> <span class="keyword">return</span> searchBST(root.left, target);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 去右⼦树搜索</span></span><br><span class="line"> <span class="keyword">if</span> (root.val &lt; target) &#123;</span><br><span class="line"> <span class="keyword">return</span> searchBST(root.right, target);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"> <span class="comment">// 找到空位置插⼊新节点</span></span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line"> <span class="comment">// if (root.val == val)</span></span><br><span class="line"> <span class="comment">// BST 中⼀般不会插⼊已存在元素</span></span><br><span class="line"> <span class="keyword">if</span> (root.val &lt; val)</span><br><span class="line"> root.right = insertIntoBST(root.right, val);</span><br><span class="line"> <span class="keyword">if</span> (root.val &gt; val)</span><br><span class="line"> root.left = insertIntoBST(root.left, val);</span><br><span class="line"> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实际上就是把搜索过程中的节点用递归的方式再次连接一次</strong></p><p>删除：</p><p>删除比较复杂，删除一个元素后，该如果有子树，需要将右子树的最小值或者左子树的最大值放到根节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line"> <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line"> <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line"> <span class="comment">// 处理情况 3</span></span><br><span class="line"> <span class="comment">// 获得右⼦树最⼩的节点</span></span><br><span class="line"> <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line"> <span class="comment">// 删除右⼦树最⼩的节点</span></span><br><span class="line"> root.right = deleteNode(root.right, minNode.val);</span><br><span class="line"> <span class="comment">// ⽤右⼦树最⼩的节点替换 root 节点</span></span><br><span class="line"> minNode.left = root.left;</span><br><span class="line"> minNode.right = root.right;</span><br><span class="line"> root = minNode;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line"> root.left = deleteNode(root.left, key);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line"> root.right = deleteNode(root.right, key);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode <span class="title function_">getMin</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line"> <span class="comment">// BST 最左边的就是最⼩的</span></span><br><span class="line"> <span class="keyword">while</span> (node.left != <span class="literal">null</span>) node = node.left;</span><br><span class="line"> <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能直接交换删除节点和替换的根节点的值，因为在实际应⽤中，BST 节点内部的数据域是⽤户⾃定义的，可以⾮常复杂，⽽ BST 作为数据结构（⼀个⼯ 具⼈），其操作应该和内部存储的数据域解耦，所以我们更倾向于使⽤指针操作来交换节点，根本没必要关 ⼼内部数据。</p><h1 id="不同的⼆叉搜索树"><a href="#不同的⼆叉搜索树" class="headerlink" title="不同的⼆叉搜索树"></a><em><strong><a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的⼆叉搜索树</a></strong></em></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum+= numTrees(i-<span class="number">1</span>)*numTrees(n-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>本质上，一定数量的节点的树数量一定，数据不同就是不同树</p><p>可以改成记忆化搜索的dp</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] G = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">       G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">               G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> G[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>和上面的递归本质一样。 i就是n</p><h1 id="⼆叉搜索⼦树的最⼤键值和"><a href="#⼆叉搜索⼦树的最⼤键值和" class="headerlink" title="⼆叉搜索⼦树的最⼤键值和"></a><em><strong><a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">⼆叉搜索⼦树的最⼤键值和</a></strong></em></h1><p>这个问题关键在于三点：</p><p>子树是不是BST，如果整个树都是BST显然非常好做</p><p>如何判断目前节点加上子树是不是二叉树？这需要获取到子树的最小值和最大值</p><p>获得子树的value和</p><p>所以使用一个长度为4的数组来记录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">traverse(root) 返回⼀个⼤⼩为 <span class="number">4</span> 的 <span class="type">int</span> 数组，我们暂且称它为 res，其中：</span><br><span class="line">res[<span class="number">0</span>] 记录以 root 为根的⼆叉树是否是 BST，若为 <span class="number">1</span> 则说明是 BST，若为 <span class="number">0</span> 则说明不是 BST；</span><br><span class="line">res[<span class="number">1</span>] 记录以 root 为根的⼆叉树所有节点中的最⼩值；</span><br><span class="line">res[<span class="number">2</span>] 记录以 root 为根的⼆叉树所有节点中的最⼤值；</span><br><span class="line">res[<span class="number">3</span>] 记录以 root 为根的⼆叉树所有节点值之和。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line"> <span class="comment">// base case</span></span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line"> <span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span></span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归计算左右⼦树</span></span><br><span class="line"> <span class="type">int</span>[] left = traverse(root.left);</span><br><span class="line"> <span class="type">int</span>[] right = traverse(root.right);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/******* 后序遍历位置 *******/</span></span><br><span class="line"> <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"> <span class="comment">// 这个 if 在判断以 root 为根的⼆叉树是不是 BST</span></span><br><span class="line"> <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp;</span><br><span class="line"> root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line"> <span class="comment">// 以 root 为根的⼆叉树是 BST</span></span><br><span class="line"> res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 计算以 root 为根的这棵 BST 的最⼩值</span></span><br><span class="line"> res[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line"> <span class="comment">// 计算以 root 为根的这棵 BST 的最⼤值</span></span><br><span class="line"> res[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line"> <span class="comment">// 计算以 root 为根的这棵 BST 所有节点之和</span></span><br><span class="line"> res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line"> <span class="comment">// 更新全局变量</span></span><br><span class="line"> maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 以 root 为根的⼆叉树不是 BST</span></span><br><span class="line"> res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 其他的值都没必要计算了，因为⽤不到</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**************************/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2024/09/23/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/09/23/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="⼆叉树的重要性"><a href="#⼆叉树的重要性" class="headerlink" title="⼆叉树的重要性"></a>⼆叉树的重要性</h1><p>快速排序就是个⼆叉树的前序遍历，归并排序就是个⼆叉树的后序遍历</p><p>前序遍历：先找中间节点</p><p>归并：分治法</p><p><strong>前中后序是遍历⼆叉树过程中处理每⼀个节点的三个特殊时间点</strong></p><p>例如：如何利用递归倒序输出链表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归遍历单链表，倒序打印链表元素 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> traverse(head.next);</span><br><span class="line"> <span class="comment">// 后序位置</span></span><br><span class="line"> print(head.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前序位置的代码在刚刚进⼊⼀个⼆叉树节点的时候执⾏；</p><p> 后序位置的代码在将要离开⼀个⼆叉树节点的时候执⾏； </p><p>中序位置的代码在⼀个⼆叉树节点左⼦树都遍历完，即将开始遍历右⼦树的时候执⾏。</p><h1 id="两种解题思路"><a href="#两种解题思路" class="headerlink" title="两种解题思路"></a><strong>两种解题思路</strong></h1><p><strong>遍历一遍二叉树</strong>和<strong>分解问题</strong></p><p>例如二叉树最大深度</p><p>遍历法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录最⼤深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录遍历到的节点的深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">traverse(root);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⼆叉树遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前序位置</span></span><br><span class="line">depth++;</span><br><span class="line"> <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 到达叶⼦节点，更新最⼤深度</span></span><br><span class="line">res = Math.max(res, depth);</span><br><span class="line"> &#125;</span><br><span class="line">traverse(root.left);</span><br><span class="line">traverse(root.right);</span><br><span class="line"><span class="comment">// 后序位置</span></span><br><span class="line">depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分治法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输⼊根节点，返回这棵⼆叉树的最⼤深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利⽤定义，计算左右⼦树的最⼤深度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line"><span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"><span class="comment">// 整棵树的最⼤深度等于左右⼦树的最⼤深度取最⼤值，</span></span><br><span class="line"> <span class="comment">// 然后再加上根节点⾃⼰</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="⼆叉树的直径"><a href="#⼆叉树的直径" class="headerlink" title="⼆叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/submissions/">⼆叉树的直径</a></h2><p>我的思路：二叉树的直径有三种可能</p><p>左子树的最大直径，右子树最大直径，左右子树最大深度相加，三者取最大值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftmax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightmax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftmax+rightmax,diameterOfBinaryTree(root.left)),diameterOfBinaryTree(root.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftmax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightmax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftmax &gt; rightmax ? leftmax+<span class="number">1</span> : rightmax+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是这样太慢了，会重复遍历，更好的方法是在maxdepth的时候就做最大直径寻找，维护一个max变量来比较。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录最⼤直径的⻓度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"> maxDepth(root);</span><br><span class="line"> <span class="keyword">return</span> maxDiameter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line"> <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"> <span class="comment">// 后序位置，顺便计算最⼤直径</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">myDiameter</span> <span class="operator">=</span> leftMax + rightMax;</span><br><span class="line"> maxDiameter = Math.max(maxDiameter, myDiameter);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></h2><p>我的思路：分治法，可以先反转子树本身，再交换左右子树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> ) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = tmp;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>遍历法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"> <span class="comment">// 遍历⼆叉树，交换每个节点的⼦节点</span></span><br><span class="line"> traverse(root);</span><br><span class="line"> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⼆叉树遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line"> <span class="comment">// 每⼀个节点需要做的事就是交换它的左右⼦节点</span></span><br><span class="line"> <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line"> root.left = root.right;</span><br><span class="line"> root.right = tmp;</span><br><span class="line"> <span class="comment">// 遍历框架，去遍历左右⼦树的节点</span></span><br><span class="line"> traverse(root.left);</span><br><span class="line"> traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="填充每个⼆叉树节点的右侧指针"><a href="#填充每个⼆叉树节点的右侧指针" class="headerlink" title="填充每个⼆叉树节点的右侧指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">填充每个⼆叉树节点的右侧指针</a></h2><p>层序遍历有点烦</p><p>这里可以抽象成一个三叉树</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230425145511534.png" alt="image-20230425145511534"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line">Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// 遍历「三叉树」，连接相邻节点</span></span><br><span class="line"> traverse(root.left, root.right);</span><br><span class="line"> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三叉树遍历框架</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(Node node1, Node node2)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line"> <span class="comment">// 将传⼊的两个节点穿起来</span></span><br><span class="line"> node1.next = node2;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 连接相同⽗节点的两个⼦节点</span></span><br><span class="line"> traverse(node1.left, node1.right);</span><br><span class="line"> traverse(node2.left, node2.right);</span><br><span class="line"> <span class="comment">// 连接跨越⽗节点的两个⼦节点</span></span><br><span class="line"> traverse(node1.right, node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为迭代，父节点的next一定已经被赋值好了，也恶意直接作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">            <span class="keyword">if</span>(root.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.right.next = root.next.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="将⼆叉树展开为链表"><a href="#将⼆叉树展开为链表" class="headerlink" title="将⼆叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">将⼆叉树展开为链表</a></h2><p>这题不可以traverse，因为要在原地做，不应该用多余空间</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230425150507833.png" alt="image-20230425150507833"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"> <span class="comment">// base case</span></span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 利⽤定义，把左右⼦树拉平</span></span><br><span class="line"> flatten(root.left);</span><br><span class="line"> flatten(root.right);</span><br><span class="line"> <span class="comment">/**** 后序遍历位置 ****/</span></span><br><span class="line"> <span class="comment">// 1、左右⼦树已经被拉平成⼀条链表</span></span><br><span class="line"> <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line"> <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2、将左⼦树作为右⼦树</span></span><br><span class="line"> root.left = <span class="literal">null</span>;</span><br><span class="line"> root.right = left;</span><br><span class="line"> <span class="comment">// 3、将原先的右⼦树接到当前右⼦树的末端</span></span><br><span class="line"> <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line"> <span class="keyword">while</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line"> p = p.right;</span><br><span class="line"> &#125;</span><br><span class="line"> p.right = right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最⼤⼆叉树"><a href="#最⼤⼆叉树" class="headerlink" title="最⼤⼆叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">最⼤⼆叉树</a></h2><p>递归即可，注意一下递归结束的条件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到数组中的最⼤值和对应的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>, maxVal = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先构造出根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">// 递归调⽤构造左右⼦树</span></span><br><span class="line">        root.left = build(nums, lo, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(nums, index + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="从前序和中序遍历序列构造⼆叉树"><a href="#从前序和中序遍历序列构造⼆叉树" class="headerlink" title="从前序和中序遍历序列构造⼆叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序和中序遍历序列构造⼆叉树</a></h2><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230425154501708.png" alt="image-20230425154501708"></p><p>对于前序搜索，根节点在数组第一个元素，找到根节点之后，在中序遍历中就找到了左子树和右子树的中序数组，根据左子树的中序数组数量就可以找到前序数组中左子树和右子树的分界点，从而实现递归。</p><p><img src="https://cdn.jsdelivr.net/gh/followheart26/blog-img/img/image-20230425154628805.png" alt="image-20230425154628805"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是前序遍历数组的第⼀个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">        <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        <span class="comment">// 先构造出当前根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右⼦树</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize,</span><br><span class="line">                inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd,</span><br><span class="line">                inorder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="从中序和后序遍历序列构造二叉树"><a href="#从中序和后序遍历序列构造二叉树" class="headerlink" title="从中序和后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序和后序遍历序列构造二叉树</a></h2><p>和上题基本同理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            valToIndex.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (postStart &gt; postEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是前序遍历数组的第⼀个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">        <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        <span class="comment">// 先构造出当前根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右⼦树</span></span><br><span class="line">        root.left = build(postorder, postStart , postStart + leftSize-<span class="number">1</span>,</span><br><span class="line">                inorder, inStart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(postorder, postStart + leftSize, postEnd-<span class="number">1</span>,</span><br><span class="line">                inorder, index + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="从前序和后续遍历序列构造二叉树"><a href="#从前序和后续遍历序列构造二叉树" class="headerlink" title="从前序和后续遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/submissions/">从前序和后续遍历序列构造二叉树</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; postorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(postorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>,</span><br><span class="line">                postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]</span></span><br><span class="line">    <span class="comment">// 构建⼆叉树，并返回根节点。</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preStart == preEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preStart]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是前序遍历数组的第⼀个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preStart];</span><br><span class="line">        <span class="comment">// root.left 的值是前序遍历第⼆个元素</span></span><br><span class="line">        <span class="comment">// 通过前序和后序遍历构造⼆叉树的关键在于通过左⼦树的根节点</span></span><br><span class="line">        <span class="comment">// 确定 preorder 和 postorder 中左右⼦树的元素区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// leftRootVal 在后序遍历数组中的索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(leftRootVal);</span><br><span class="line">        <span class="comment">// 左⼦树的元素个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - postStart + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 先构造出当前根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右⼦树</span></span><br><span class="line">        <span class="comment">// 根据左⼦树的根节点索引和元素个数推导左右⼦树的索引边界</span></span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, preStart + leftSize,</span><br><span class="line">                postorder, postStart, index);</span><br><span class="line">        root.right = build(preorder, preStart + leftSize + <span class="number">1</span>, preEnd,</span><br><span class="line">                postorder, index + <span class="number">1</span>, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前序和后序构造不唯一的问题在于我们认为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preStart + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>而实际上当左子树为空，这个节点实际应当在右子树</p><h2 id="⼆叉树的序列化与反序列化"><a href="#⼆叉树的序列化与反序列化" class="headerlink" title="⼆叉树的序列化与反序列化"></a><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">⼆叉树的序列化与反序列化</a></h2><p>序列化很简单，遍历即可，前序，后序，层序都可以</p><p>但是如何反序列化呢</p><p>反序列化关键在于左子树和右子树的分界点在哪里，序列化的时候，若子树为空则加上标记符#</p><p>遇到#说明该子树不存在，应当结束递归。</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将二叉树序列化为字符串 */</span></span><br><span class="line">    String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，将二叉树存入 StringBuilder */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            sb.append(NULL).append(SEP);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left,sb);</span><br><span class="line">        serialize(root.right,sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            nodes.addLast(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (first.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(first));</span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><code>removefirst</code>换成<code>removelast</code>，先构造右子树，再构造左子树即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 主函数，将字符串反序列化为二叉树结构 */</span></span><br><span class="line">TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">        nodes.addLast(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span></span><br><span class="line">TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 从后往前取出元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> nodes.removeLast();</span><br><span class="line">    <span class="keyword">if</span> (last.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(last));</span><br><span class="line">    <span class="comment">// 限构造右子树，后构造左子树</span></span><br><span class="line">    root.right = deserialize(nodes);</span><br><span class="line">    root.left = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>先看看层序遍历的框架</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 层级遍历代码位置 */</span></span><br><span class="line">        System.out.println(root.val);</span><br><span class="line">        <span class="comment">/*****************/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化套框架就好</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将二叉树序列化为字符串 */</span></span><br><span class="line">String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 层级遍历代码位置 */</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(NULL).append(SEP);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(cur.val).append(SEP);</span><br><span class="line">        <span class="comment">/*****************/</span></span><br><span class="line"></span><br><span class="line">        q.offer(cur.left);</span><br><span class="line">        q.offer(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化每次开始时将节点poll出来，按顺序连接左右节点，结束时，将所有子节点offer入queue中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将二叉树序列化为字符串 */</span></span><br><span class="line">String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 层级遍历代码位置 */</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(NULL).append(SEP);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(cur.val).append(SEP);</span><br><span class="line">        <span class="comment">/*****************/</span></span><br><span class="line"></span><br><span class="line">        q.offer(cur.left);</span><br><span class="line">        q.offer(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找重复的⼦树"><a href="#寻找重复的⼦树" class="headerlink" title="寻找重复的⼦树"></a><a href="https://leetcode.cn/problems/find-duplicate-subtrees/">寻找重复的⼦树</a></h2><p>基本思路就是将一棵树以唯一且简单的方式存放起来，也就是上一题的序列化，前后序，层序都可以</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录所有子树以及出现的次数</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录重复的子树根节点</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> traverse(root.left);</span><br><span class="line">        <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">subTree</span> <span class="operator">=</span> left + <span class="string">&quot;,&quot;</span> + right + <span class="string">&quot;,&quot;</span> + root.val;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> memo.getOrDefault(subTree, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 多次重复也只会被加入结果集一次</span></span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给子树对应的出现次数加一</span></span><br><span class="line">        memo.put(subTree, freq + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> subTree;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/23/MyBatis%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/23/MyBatis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul><li>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github</li><li>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）</li></ul><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><ol><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li><li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li></ol><h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><ul><li><a href="https://github.com/mybatis/mybatis-3">MyBatis下载地址</a></li><li><img src="/Resources/MyBatis%E4%B8%8B%E8%BD%BD.png"></li></ul><h2 id="和其它持久化层技术对比"><a href="#和其它持久化层技术对比" class="headerlink" title="和其它持久化层技术对比"></a>和其它持久化层技术对比</h2><ul><li>JDBC  <ul><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  </li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见  </li><li>代码冗长，开发效率低</li></ul></li><li>Hibernate 和 JPA<ul><li>操作简便，开发效率高  </li><li>程序中的长难复杂 SQL 需要绕过框架  </li><li>内部自动生产的 SQL，不容易做特殊优化  </li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。  </li><li>反射操作太多，导致数据库性能下降</li></ul></li><li>MyBatis<ul><li>轻量级，性能出色  </li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据  </li><li>开发效率稍逊于HIbernate，但是完全能够接受</li></ul></li></ul><h1 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>IDE：idea 2019.2  </li><li>构建工具：maven 3.5.4  </li><li>MySQL版本：MySQL 5.7  </li><li>MyBatis版本：MyBatis 3.5.7</li></ul><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><ul><li>打包方式：jar</li><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h2><blockquote><p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。<br>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息<br>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>  </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的环境--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--引入映射文件--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><blockquote><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.mapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 添加用户信息  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h2><ul><li>相关概念：ORM（Object Relationship Mapping）对象关系映射。  <ul><li>对象：Java的实体类对象  </li><li>关系：关系型数据库  </li><li>映射：二者之间的对应关系</li></ul></li></ul><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段&#x2F;列</td></tr><tr><td>对象</td><td>记录&#x2F;行</td></tr></tbody></table><ul><li>映射文件的命名规则<ul><li>表所对应的实体类的类名+Mapper.xml</li><li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml </li><li>因此一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</li></ul></li><li>MyBatis中可以面向接口操作数据，要保证两个一致<ul><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span>  </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span>  </span><br><span class="line">insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)  </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><ul><li>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）</li><li>SqlSessionFactory：是“生产”SqlSession的“工厂”</li><li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line">        <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line">    <span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  </span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser();</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用<code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>，传入一个Boolean类型的参数，值为true，这样就可以自动提交</li></ul><h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><ol><li>加入依赖 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>加入log4j的配置文件<ul><li>log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下</li><li>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><blockquote><p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：<br>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">    default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment">1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">2. mapper接口要和mapper映射文件的名字一致</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><img src="/Resources/mapper%E6%8E%A5%E5%8F%A3%E5%92%8Cmapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8C%85%E4%B8%8B.png"></li></ul><h1 id="默认的类型别名"><a href="#默认的类型别名" class="headerlink" title="默认的类型别名"></a>默认的类型别名</h1><p><img src="/Resources/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D1.png"><br><img src="/Resources/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D2.png"></p><h1 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h1><ol><li>添加 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>删除 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">       delete from t_user where id = 6</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>修改 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">       update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>查询一个实体类对象 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--User getUserById();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where id = 2  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>查询集合 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>注意：</p><ol><li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  <ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况  </li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ul></li><li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li></ol></li></ul><h1 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h1><ul><li>MyBatis获取参数值的两种方式：${}和#{}  </li><li>${}的本质就是字符串拼接，#{}的本质就是占位符赋值  </li><li>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li></ul><h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><ul><li><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p><ol><li>以arg0,arg1…为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li><p>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。</p></li><li><p>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><ul><li>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;usermane&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkLoginByMap(map);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><ul><li>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">12</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><ul><li><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 </p><ol><li>以@Param注解的value属性值为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;CheckLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByParam</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">mapper.CheckLoginByParam(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>建议分成两种情况进行处理</p><ol><li>实体类类型的参数</li><li>使用@Param标识参数</li></ol></li></ul><h1 id="MyBatis的各种查询功能"><a href="#MyBatis的各种查询功能" class="headerlink" title="MyBatis的各种查询功能"></a>MyBatis的各种查询功能</h1><ol><li>如果查询出的数据只有一条，可以通过<ol><li>实体类对象接收</li><li>List集合接收</li><li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li></ol></li><li>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过<ol><li>实体类类型的LIst集合接收</li><li>Map类型的LIst集合接收</li><li>在mapper接口的方法上添加@MapKey注解</li></ol></li></ol><h2 id="查询一个实体类对象"><a href="#查询一个实体类对象" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询一个List集合"><a href="#查询一个List集合" class="headerlink" title="查询一个List集合"></a>查询一个List集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询单个数据"><a href="#查询单个数据" class="headerlink" title="查询单个数据"></a>查询单个数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询用户的总记录数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 在MyBatis中，对于Java中常用的类型都设置了类型别名  </span></span><br><span class="line"><span class="comment"> * 例如：java.lang.Integer--&gt;int|integer  </span></span><br><span class="line"><span class="comment"> * 例如：int--&gt;_int|_integer  </span></span><br><span class="line"><span class="comment"> * 例如：Map--&gt;map,List--&gt;list  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int getCount();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;_integer&quot;</span>&gt;</span></span><br><span class="line">select count(id) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询一条数据为map集合"><a href="#查询一条数据为map集合" class="headerlink" title="查询一条数据为map集合"></a>查询一条数据为map集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getUserToMap</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询多条数据为map集合"><a href="#查询多条数据为map集合" class="headerlink" title="查询多条数据为map集合"></a>查询多条数据为map集合</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">[&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的map集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h1 id="特殊SQL的执行"><a href="#特殊SQL的执行" class="headerlink" title="特殊SQL的执行"></a>特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名进行模糊查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByLike</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span>  </span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>其中<code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>是最常用的</li></ul><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><ul><li>只能使用${}，如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为<code>1,2,3</code>的数据会被删除。正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id批量删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteMore</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMore</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">SQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SQLMapper.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.deleteMore(<span class="string">&quot;1,2,3,8&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><ul><li>只能使用${}，因为表名不能加单引号<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定表中的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableName </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 14:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByTable</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h2><ul><li>使用场景<ul><li>t_clazz(clazz_id,clazz_name)  </li><li>t_student(student_id,student_name,clazz_id)</li></ul><ol><li>添加班级信息  </li><li>获取新添加的班级的id  </li><li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li></ol></li><li>在mapper.xml中设置两个属性<ul><li>useGeneratedKeys：设置使用自增的主键</li></ul><ul><li>keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--void insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">SQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SQLMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;ton&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="comment">//输出：user&#123;id=10, username=&#x27;ton&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@321.com&#x27;&#125;，自增主键存放到了user的id属性中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><h2 id="resultMap处理字段和属性的映射关系"><a href="#resultMap处理字段和属性的映射关系" class="headerlink" title="resultMap处理字段和属性的映射关系"></a>resultMap处理字段和属性的映射关系</h2><ul><li><p>resultMap：设置自定义映射  </p><ul><li>属性：  <ul><li>id：表示自定义映射的唯一标识，不能重复</li><li>type：查询的数据要映射的实体类的类型</li></ul></li><li>子标签：  <ul><li>id：设置主键的映射关系  </li><li>result：设置普通字段的映射关系  </li><li>子标签属性：  <ul><li>property：设置映射关系中实体类中的属性名  </li><li>column：设置映射关系中表中的字段名</li></ul></li></ul></li></ul></li><li><p>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系  </p><ol><li>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select eid,emp_name empName,age,sex,email from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>可以在MyBatis的核心配置文件中的<code>setting</code>标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。<a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">核心配置文件详解</a> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="多对一映射处理"><a href="#多对一映射处理" class="headerlink" title="多对一映射处理"></a>多对一映射处理</h2><blockquote><p>查询员工信息以及员工所对应的部门信息</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;  </span><br><span class="line"><span class="keyword">private</span> Integer eid;  </span><br><span class="line"><span class="keyword">private</span> String empName;  </span><br><span class="line"><span class="keyword">private</span> Integer age;  </span><br><span class="line"><span class="keyword">private</span> String sex;  </span><br><span class="line"><span class="keyword">private</span> String email;  </span><br><span class="line"><span class="keyword">private</span> Dept dept;</span><br><span class="line"><span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="级联方式处理映射关系"><a href="#级联方式处理映射关系" class="headerlink" title="级联方式处理映射关系"></a>级联方式处理映射关系</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3><ul><li>association：处理多对一的映射关系</li><li>property：需要处理多对的映射关系的属性名</li><li>javaType：该属性的类型<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询员工信息"><a href="#1-查询员工信息" class="headerlink" title="1. 查询员工信息"></a>1. 查询员工信息</h4><ul><li>select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</li><li>column：设置分步查询的条件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmpMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Emp <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> Integer eid)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-查询部门信息"><a href="#2-查询部门信息" class="headerlink" title="2. 查询部门信息"></a>2. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DeptMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：通过did查询员工对应的部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getEmpAndDeptByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer did;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line"><span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ul><li>collection：用来处理一对多的映射关系</li><li>ofType：表示该属性对饮的集合中存储的数据的类型<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询部门信息"><a href="#1-查询部门信息" class="headerlink" title="1. 查询部门信息"></a>1. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Dept</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getDeptAndEmpByStepOne</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-根据部门id查询部门中的所有员工"><a href="#2-根据部门id查询部门中的所有员工" class="headerlink" title="2. 根据部门id查询部门中的所有员工"></a>2. 根据部门id查询部门中的所有员工</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：根据部门id查询部门中的所有员工</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getDeptAndEmpByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ul><li>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：<ul><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  </li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</li></ul></li><li>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">System.out.println(emp.getEmpName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关闭延迟加载，两条SQL语句都运行了<img src="/Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%951.png"></li><li>开启延迟加载，只运行获取emp的SQL语句<br><img src="/Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%952.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">System.out.println(emp.getEmpName());</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">System.out.println(emp.getDept());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>开启后，需要用到查询dept的时候才会调用相应的SQL语句<img src="/Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%953.png"></li><li>fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><ul><li>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul><li>if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li><li>在where后面添加一个恒成立条件<code>1=1</code><ul><li>这个恒成立条件并不会影响查询的结果</li><li>这个<code>1=1</code>可以用来拼接<code>and</code>语句，例如：当empName为null时<ul><li>如果不加上恒成立条件，则SQL语句为<code>select * from t_emp where and age = ? and sex = ? and email = ?</code>，此时<code>where</code>会与<code>and</code>连用，SQL语句会报错</li><li>如果加上一个恒成立条件，则SQL语句为<code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code>，此时不报错</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><ul><li>where和if一般结合使用：<ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  </li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and&#x2F;or去掉  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>注意：where标签不能去掉条件后多余的and&#x2F;or</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul><li>trim用于去掉或添加标签中的内容  </li><li>常用属性<ul><li>prefix：在trim标签中的内容的前面添加某些内容  </li><li>suffix：在trim标签中的内容的后面添加某些内容 </li><li>prefixOverrides：在trim标签中的内容的前面去掉某些内容  </li><li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li></ul></li><li>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125; or</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpByCondition</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">List&lt;Emp&gt; emps= mapper.getEmpByCondition(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/Resources/trim%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></li></ul><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul><li><code>choose、when、otherwise</code>相当于<code>if...else if..else</code></li><li>when至少要有一个，otherwise至多只有一个<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">did = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpByChoose</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.getEmpByChoose(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>, <span class="literal">null</span>));</span><br><span class="line">System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/Resources/choose%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></li><li>相当于<code>if a else if b else if c else d</code>，只会执行其中一个</li></ul><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul><li>属性：  <ul><li>collection：设置要循环的数组或集合  </li><li>item：表示集合或数组中的每一个数据  </li><li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如<code>,</code></li><li>open：设置foreach标签中的内容的开始符  </li><li>close：设置foreach标签中的内容的结束符</li></ul></li><li>批量删除</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">delete from t_emp where eid in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMoreByArray</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.deleteMoreByArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>![](Resources/foreach测试结果1.png)</code></pre><ul><li>批量添加</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreByList&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertMoreByList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;c&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertMoreByList(emps);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>![](Resources/foreach测试结果2.png)</code></pre><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ul><li>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</li><li>声明sql片段：<code>&lt;sql&gt;</code>标签<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>引用sql片段：<code>&lt;include&gt;</code>标签<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><ul><li><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问  </p></li><li><p>使一级缓存失效的四种情况：  </p><ol><li>不同的SqlSession对应不同的一级缓存  </li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ol></li></ul><h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><ul><li><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取  </p></li><li><p>二级缓存开启的条件</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置</li><li>在映射文件中设置标签<cache /></li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol></li><li><p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p></li></ul><h2 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h2><ul><li>在mapper配置文件中添加的cache标签可以设置一些属性</li><li>eviction属性：缓存回收策略  <ul><li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  </li><li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。  </li><li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。  </li><li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li><li>默认的是 LRU</li></ul></li><li>flushInterval属性：刷新间隔，单位毫秒<ul><li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</li></ul></li><li>size属性：引用数目，正整数<ul><li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li></ul></li><li>readOnly属性：只读，true&#x2F;false<ul><li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  </li><li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false</li></ul></li></ul><h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><ul><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用  </li><li>如果二级缓存没有命中，再查询一级缓存  </li><li>如果一级缓存也没有命中，则查询数据库  </li><li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li></ul><h2 id="整合第三方缓存EHCache（了解）"><a href="#整合第三方缓存EHCache（了解）" class="headerlink" title="整合第三方缓存EHCache（了解）"></a>整合第三方缓存EHCache（了解）</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="各个jar包的功能"><a href="#各个jar包的功能" class="headerlink" title="各个jar包的功能"></a>各个jar包的功能</h3><table><thead><tr><th>jar包名称</th><th>作用</th></tr></thead><tbody><tr><td>mybatis-ehcache</td><td>Mybatis和EHCache的整合包</td></tr><tr><td>ehcache</td><td>EHCache核心包</td></tr><tr><td>slf4j-api</td><td>SLF4J日志门面包</td></tr><tr><td>logback-classic</td><td>支持SLF4J门面接口的一个具体实现</td></tr></tbody></table><h3 id="创建EHCache的配置文件ehcache-xml"><a href="#创建EHCache的配置文件ehcache-xml" class="headerlink" title="创建EHCache的配置文件ehcache.xml"></a>创建EHCache的配置文件ehcache.xml</h3><ul><li>名字必须叫<code>ehcache.xml</code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="设置二级缓存的类型"><a href="#设置二级缓存的类型" class="headerlink" title="设置二级缓存的类型"></a>设置二级缓存的类型</h3><ul><li>在xxxMapper.xml文件中设置二级缓存类型<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="加入logback日志"><a href="#加入logback日志" class="headerlink" title="加入logback日志"></a>加入logback日志</h3><ul><li>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件<code>logback.xml</code>，名字固定，不可改变<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="EHCache配置文件说明"><a href="#EHCache配置文件说明" class="headerlink" title="EHCache配置文件说明"></a>EHCache配置文件说明</h3><table><thead><tr><th>属性名</th><th>是否必须</th><th>作用</th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出</td></tr></tbody></table><h1 id="MyBatis的逆向工程"><a href="#MyBatis的逆向工程" class="headerlink" title="MyBatis的逆向工程"></a>MyBatis的逆向工程</h1><ul><li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</li><li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：  <ul><li>Java实体类  </li><li>Mapper接口  </li><li>Mapper映射文件</li></ul></li></ul><h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><h3 id="添加依赖和插件"><a href="#添加依赖和插件" class="headerlink" title="添加依赖和插件"></a>添加依赖和插件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MyBatis核心依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建MyBatis的核心配置文件-1"><a href="#创建MyBatis的核心配置文件-1" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建逆向工程的配置文件"><a href="#创建逆向工程的配置文件" class="headerlink" title="创建逆向工程的配置文件"></a>创建逆向工程的配置文件</h3><ul><li>文件名必须是：<code>generatorConfig.xml</code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="执行MBG插件的generate目标"><a href="#执行MBG插件的generate目标" class="headerlink" title="执行MBG插件的generate目标"></a>执行MBG插件的generate目标</h3><ul><li><img src="/Resources/%E6%89%A7%E8%A1%8CMBG%E6%8F%92%E4%BB%B6%E7%9A%84generate%E7%9B%AE%E6%A0%87.png"></li><li>如果出现报错：<code>Exception getting JDBC Driver</code>，可能是pom.xml中，数据库驱动配置错误<ul><li>dependency中的驱动<img src="/Resources/dependency%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png"></li><li>mybatis-generator-maven-plugin插件中的驱动<img src="/Resources/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png"></li><li>两者的驱动版本应该相同</li></ul></li><li>执行结果<img src="/Resources/%E9%80%86%E5%90%91%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></li></ul><h2 id="QBC"><a href="#QBC" class="headerlink" title="QBC"></a>QBC</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li><code>selectByExample</code>：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据</li><li><code>example.createCriteria().xxx</code>：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</li><li><code>example.or().xxx</code>：将之前添加的条件通过or拼接其他条件<br><img src="/Resources/example%E7%9A%84%E6%96%B9%E6%B3%95.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">EmpExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpExample</span>();</span><br><span class="line"><span class="comment">//名字为张三，且年龄大于等于20</span></span><br><span class="line">example.createCriteria().andEmpNameEqualTo(<span class="string">&quot;张三&quot;</span>).andAgeGreaterThanOrEqualTo(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//或者did不为空</span></span><br><span class="line">example.or().andDidIsNotNull();</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(example);</span><br><span class="line">emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/Resources/example%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></li></ul><h3 id="增改"><a href="#增改" class="headerlink" title="增改"></a>增改</h3><ul><li><code>updateByPrimaryKey</code>：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null<ul><li><code>mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li><li><img src="/Resources/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png"></li></ul></li><li><code>updateByPrimaryKeySelective()</code>：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段<ul><li><code>mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li><li><img src="/Resources/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png"></li></ul></li></ul><h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><h2 id="分页插件使用步骤"><a href="#分页插件使用步骤" class="headerlink" title="分页插件使用步骤"></a>分页插件使用步骤</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h3><ul><li>在MyBatis的核心配置文件（mybatis-config.xml）中配置插件</li><li><img src="/Resources/%E9%85%8D%E7%BD%AE%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6.png"><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><h3 id="开启分页功能"><a href="#开启分页功能" class="headerlink" title="开启分页功能"></a>开启分页功能</h3><ul><li>在查询功能之前使用<code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能<ul><li>pageNum：当前页的页码  </li><li>pageSize：每页显示的条数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/Resources/%E5%88%86%E9%A1%B5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p><h3 id="分页相关数据"><a href="#分页相关数据" class="headerlink" title="分页相关数据"></a>分页相关数据</h3><h4 id="方法一：直接输出"><a href="#方法一：直接输出" class="headerlink" title="方法一：直接输出"></a>方法一：直接输出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//在查询到List集合后，打印分页数据</span></span><br><span class="line">System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分页相关数据：</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;]</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法二使用PageInfo"><a href="#方法二使用PageInfo" class="headerlink" title="方法二使用PageInfo"></a>方法二使用PageInfo</h4><ul><li><p>在查询获取list集合之后，使用<code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>获取分页相关数据</p><ul><li>list：分页之后的数据  </li><li>navigatePages：导航分页的页码数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">PageInfo&lt;Emp&gt; page = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(emps,<span class="number">5</span>);</span><br><span class="line">System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分页相关数据：</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, </span><br><span class="line">list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;], </span><br><span class="line">prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125;</span><br></pre></td></tr></table></figure></li><li><p>其中list中的数据等同于方法一中直接输出的page数据</p></li></ul><h4 id="常用数据："><a href="#常用数据：" class="headerlink" title="常用数据："></a>常用数据：</h4><ul><li>pageNum：当前页的页码  </li><li>pageSize：每页显示的条数  </li><li>size：当前页显示的真实条数  </li><li>total：总记录数  </li><li>pages：总页数  </li><li>prePage：上一页的页码  </li><li>nextPage：下一页的页码</li><li>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页  </li><li>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页  </li><li>navigatePages：导航分页的页码数  </li><li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
